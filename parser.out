Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> function_list
Rule 1     function_list -> function function_list
Rule 2     function_list -> empty
Rule 3     function -> TYPE VARIABLE ( arguments ) { body }
Rule 4     arguments -> TYPE variable_or_pointer
Rule 5     arguments -> TYPE variable_or_pointer , arguments
Rule 6     arguments -> TYPE
Rule 7     arguments -> TYPE , arguments
Rule 8     body -> line body
Rule 9     body -> empty
Rule 10    line -> declaration
Rule 11    line -> assignment
Rule 12    line -> if_clause
Rule 13    line -> for_loop
Rule 14    line -> expr_line
Rule 15    line -> return_expr
Rule 16    line -> printf_expr
Rule 17    declaration -> TYPE variable_list ;
Rule 18    declaration -> TYPE variable_list
Rule 19    variable_list -> variable_or_pointer
Rule 20    variable_list -> array
Rule 21    variable_list -> variable_or_pointer , variable_list
Rule 22    variable_list -> array , variable_list
Rule 23    assignment -> variable_or_pointer = expr_1 ;
Rule 24    assignment -> array = expr_1 ;
Rule 25    assignment -> variable_or_pointer = error ;
Rule 26    assignment -> array = error ;
Rule 27    assignment -> variable_or_pointer = & VARIABLE ;
Rule 28    assignment -> array = & VARIABLE ;
Rule 29    return_expr -> RETURN expr_1 ;
Rule 30    return_expr -> RETURN ;
Rule 31    expr_line -> expr_1 ;
Rule 32    printf_expr -> PRINTF ( STRING ) ;
Rule 33    printf_expr -> PRINTF ( digit ) ;
Rule 34    printf_expr -> PRINTF ( float ) ;
Rule 35    digit -> DIGIT_STRING , expr_1
Rule 36    float -> FLOAT_STRING , expr_1
Rule 37    variable_or_pointer -> * VARIABLE
Rule 38    variable_or_pointer -> VARIABLE
Rule 39    expr_1 -> expr_2 > expr_1
Rule 40    expr_1 -> expr_2 < expr_1
Rule 41    expr_1 -> expr_2
Rule 42    expr_2 -> expr_3 PLUS expr_2
Rule 43    expr_2 -> expr_3 - expr_2
Rule 44    expr_2 -> expr_3
Rule 45    expr_3 -> expr_4 * expr_3
Rule 46    expr_3 -> expr_4 / expr_3
Rule 47    expr_3 -> expr_4
Rule 48    expr_4 -> - expr_5
Rule 49    expr_4 -> expr_5
Rule 50    expr_5 -> variable_or_pointer INCR
Rule 51    expr_5 -> expr_6
Rule 52    expr_6 -> INTEGER
Rule 53    expr_6 -> variable_or_pointer
Rule 54    expr_6 -> function_call
Rule 55    expr_6 -> array
Rule 56    expr_6 -> ( expr_1 )
Rule 57    if_clause -> IF ( expr_1 ) { body }
Rule 58    for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body }
Rule 59    for_loop -> FOR ( assignment expr_1 ; expr_1 ) body }
Rule 60    for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body
Rule 61    function_call -> VARIABLE ( arguments_call )
Rule 62    arguments_call -> expr_1
Rule 63    arguments_call -> expr_1 , arguments_call
Rule 64    array -> VARIABLE [ expr_1 ]
Rule 65    empty -> <empty>

Terminals, with rules where they appear

&                    : 27 28
(                    : 3 32 33 34 56 57 58 59 60 61
)                    : 3 32 33 34 56 57 58 59 60 61
*                    : 37 45
,                    : 5 7 21 22 35 36 63
-                    : 43 48
/                    : 46
;                    : 17 23 24 25 26 27 28 29 30 31 32 33 34 58 59 60
<                    : 40
=                    : 23 24 25 26 27 28
>                    : 39
DIGIT_STRING         : 35
FLOAT_STRING         : 36
FOR                  : 58 59 60
IF                   : 57
INCR                 : 50
INTEGER              : 52
PLUS                 : 42
PRINTF               : 32 33 34
RETURN               : 29 30
STRING               : 32
TYPE                 : 3 4 5 6 7 17 18
VARIABLE             : 3 27 28 37 38 61 64
[                    : 64
]                    : 64
error                : 25 26
{                    : 3 57 58 60
}                    : 3 57 58 59

Nonterminals, with rules where they appear

arguments            : 3 5 7
arguments_call       : 61 63
array                : 20 22 24 26 28 55
assignment           : 11 58 59 60
body                 : 3 8 57 58 59 60
declaration          : 10
digit                : 33
empty                : 2 9
expr_1               : 23 24 29 31 35 36 39 40 56 57 58 58 59 59 60 60 62 63 64
expr_2               : 39 40 41 42 43
expr_3               : 42 43 44 45 46
expr_4               : 45 46 47
expr_5               : 48 49
expr_6               : 51
expr_line            : 14
float                : 34
for_loop             : 13
function             : 1
function_call        : 54
function_list        : 1 0
if_clause            : 12
line                 : 8
printf_expr          : 16
return_expr          : 15
variable_list        : 17 18 21 22
variable_or_pointer  : 4 5 19 21 23 25 27 50 53

Parsing method: LALR

state 0

    (0) S' -> . function_list
    (1) function_list -> . function function_list
    (2) function_list -> . empty
    (3) function -> . TYPE VARIABLE ( arguments ) { body }
    (65) empty -> .

    TYPE            shift and go to state 4
    $end            reduce using rule 65 (empty -> .)

    function_list                  shift and go to state 1
    function                       shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> function_list .



state 2

    (1) function_list -> function . function_list
    (1) function_list -> . function function_list
    (2) function_list -> . empty
    (3) function -> . TYPE VARIABLE ( arguments ) { body }
    (65) empty -> .

    TYPE            shift and go to state 4
    $end            reduce using rule 65 (empty -> .)

    function                       shift and go to state 2
    function_list                  shift and go to state 5
    empty                          shift and go to state 3

state 3

    (2) function_list -> empty .

    $end            reduce using rule 2 (function_list -> empty .)


state 4

    (3) function -> TYPE . VARIABLE ( arguments ) { body }

    VARIABLE        shift and go to state 6


state 5

    (1) function_list -> function function_list .

    $end            reduce using rule 1 (function_list -> function function_list .)


state 6

    (3) function -> TYPE VARIABLE . ( arguments ) { body }

    (               shift and go to state 7


state 7

    (3) function -> TYPE VARIABLE ( . arguments ) { body }
    (4) arguments -> . TYPE variable_or_pointer
    (5) arguments -> . TYPE variable_or_pointer , arguments
    (6) arguments -> . TYPE
    (7) arguments -> . TYPE , arguments

    TYPE            shift and go to state 8

    arguments                      shift and go to state 9

state 8

    (4) arguments -> TYPE . variable_or_pointer
    (5) arguments -> TYPE . variable_or_pointer , arguments
    (6) arguments -> TYPE .
    (7) arguments -> TYPE . , arguments
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE

    )               reduce using rule 6 (arguments -> TYPE .)
    ,               shift and go to state 11
    *               shift and go to state 12
    VARIABLE        shift and go to state 13

    variable_or_pointer            shift and go to state 10

state 9

    (3) function -> TYPE VARIABLE ( arguments . ) { body }

    )               shift and go to state 14


state 10

    (4) arguments -> TYPE variable_or_pointer .
    (5) arguments -> TYPE variable_or_pointer . , arguments

    )               reduce using rule 4 (arguments -> TYPE variable_or_pointer .)
    ,               shift and go to state 15


state 11

    (7) arguments -> TYPE , . arguments
    (4) arguments -> . TYPE variable_or_pointer
    (5) arguments -> . TYPE variable_or_pointer , arguments
    (6) arguments -> . TYPE
    (7) arguments -> . TYPE , arguments

    TYPE            shift and go to state 8

    arguments                      shift and go to state 16

state 12

    (37) variable_or_pointer -> * . VARIABLE

    VARIABLE        shift and go to state 17


state 13

    (38) variable_or_pointer -> VARIABLE .

    ,               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    )               reduce using rule 38 (variable_or_pointer -> VARIABLE .)


state 14

    (3) function -> TYPE VARIABLE ( arguments ) . { body }

    {               shift and go to state 18


state 15

    (5) arguments -> TYPE variable_or_pointer , . arguments
    (4) arguments -> . TYPE variable_or_pointer
    (5) arguments -> . TYPE variable_or_pointer , arguments
    (6) arguments -> . TYPE
    (7) arguments -> . TYPE , arguments

    TYPE            shift and go to state 8

    arguments                      shift and go to state 19

state 16

    (7) arguments -> TYPE , arguments .

    )               reduce using rule 7 (arguments -> TYPE , arguments .)


state 17

    (37) variable_or_pointer -> * VARIABLE .

    ,               reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    )               reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    =               reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    INCR            reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    *               reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    /               reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    PLUS            reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    -               reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    >               reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    <               reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    ;               reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    TYPE            reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    IF              reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    FOR             reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    RETURN          reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    PRINTF          reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    VARIABLE        reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    INTEGER         reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    (               reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    }               reduce using rule 37 (variable_or_pointer -> * VARIABLE .)
    ]               reduce using rule 37 (variable_or_pointer -> * VARIABLE .)


state 18

    (3) function -> TYPE VARIABLE ( arguments ) { . body }
    (8) body -> . line body
    (9) body -> . empty
    (10) line -> . declaration
    (11) line -> . assignment
    (12) line -> . if_clause
    (13) line -> . for_loop
    (14) line -> . expr_line
    (15) line -> . return_expr
    (16) line -> . printf_expr
    (65) empty -> .
    (17) declaration -> . TYPE variable_list ;
    (18) declaration -> . TYPE variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = error ;
    (26) assignment -> . array = error ;
    (27) assignment -> . variable_or_pointer = & VARIABLE ;
    (28) assignment -> . array = & VARIABLE ;
    (57) if_clause -> . IF ( expr_1 ) { body }
    (58) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (59) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (60) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (31) expr_line -> . expr_1 ;
    (29) return_expr -> . RETURN expr_1 ;
    (30) return_expr -> . RETURN ;
    (32) printf_expr -> . PRINTF ( STRING ) ;
    (33) printf_expr -> . PRINTF ( digit ) ;
    (34) printf_expr -> . PRINTF ( float ) ;
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (64) array -> . VARIABLE [ expr_1 ]
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )

    }               reduce using rule 65 (empty -> .)
    TYPE            shift and go to state 20
    IF              shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    PRINTF          shift and go to state 39
    *               shift and go to state 12
    VARIABLE        shift and go to state 21
    -               shift and go to state 42
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    body                           shift and go to state 23
    line                           shift and go to state 24
    empty                          shift and go to state 25
    declaration                    shift and go to state 26
    assignment                     shift and go to state 27
    if_clause                      shift and go to state 28
    for_loop                       shift and go to state 29
    expr_line                      shift and go to state 30
    return_expr                    shift and go to state 31
    printf_expr                    shift and go to state 32
    variable_or_pointer            shift and go to state 33
    expr_1                         shift and go to state 34
    array                          shift and go to state 35
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47

state 19

    (5) arguments -> TYPE variable_or_pointer , arguments .

    )               reduce using rule 5 (arguments -> TYPE variable_or_pointer , arguments .)


state 20

    (17) declaration -> TYPE . variable_list ;
    (18) declaration -> TYPE . variable_list
    (19) variable_list -> . variable_or_pointer
    (20) variable_list -> . array
    (21) variable_list -> . variable_or_pointer , variable_list
    (22) variable_list -> . array , variable_list
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (64) array -> . VARIABLE [ expr_1 ]

    *               shift and go to state 12
    VARIABLE        shift and go to state 51

    variable_list                  shift and go to state 48
    variable_or_pointer            shift and go to state 49
    array                          shift and go to state 50

state 21

    (38) variable_or_pointer -> VARIABLE .
    (64) array -> VARIABLE . [ expr_1 ]
    (61) function_call -> VARIABLE . ( arguments_call )

    =               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    INCR            reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    *               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    /               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    PLUS            reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    -               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    >               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    <               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    ;               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    [               shift and go to state 52
    (               shift and go to state 53


state 22

    (56) expr_6 -> ( . expr_1 )
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_1                         shift and go to state 54
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 23

    (3) function -> TYPE VARIABLE ( arguments ) { body . }

    }               shift and go to state 58


state 24

    (8) body -> line . body
    (8) body -> . line body
    (9) body -> . empty
    (10) line -> . declaration
    (11) line -> . assignment
    (12) line -> . if_clause
    (13) line -> . for_loop
    (14) line -> . expr_line
    (15) line -> . return_expr
    (16) line -> . printf_expr
    (65) empty -> .
    (17) declaration -> . TYPE variable_list ;
    (18) declaration -> . TYPE variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = error ;
    (26) assignment -> . array = error ;
    (27) assignment -> . variable_or_pointer = & VARIABLE ;
    (28) assignment -> . array = & VARIABLE ;
    (57) if_clause -> . IF ( expr_1 ) { body }
    (58) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (59) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (60) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (31) expr_line -> . expr_1 ;
    (29) return_expr -> . RETURN expr_1 ;
    (30) return_expr -> . RETURN ;
    (32) printf_expr -> . PRINTF ( STRING ) ;
    (33) printf_expr -> . PRINTF ( digit ) ;
    (34) printf_expr -> . PRINTF ( float ) ;
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (64) array -> . VARIABLE [ expr_1 ]
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    }               reduce using rule 65 (empty -> .)
    TYPE            shift and go to state 20
    IF              shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    PRINTF          shift and go to state 39
    *               shift and go to state 12
    VARIABLE        shift and go to state 21
    -               shift and go to state 42
    INTEGER         shift and go to state 46
    (               shift and go to state 22

  ! TYPE            [ reduce using rule 65 (empty -> .) ]
  ! IF              [ reduce using rule 65 (empty -> .) ]
  ! FOR             [ reduce using rule 65 (empty -> .) ]
  ! RETURN          [ reduce using rule 65 (empty -> .) ]
  ! PRINTF          [ reduce using rule 65 (empty -> .) ]
  ! *               [ reduce using rule 65 (empty -> .) ]
  ! VARIABLE        [ reduce using rule 65 (empty -> .) ]
  ! -               [ reduce using rule 65 (empty -> .) ]
  ! INTEGER         [ reduce using rule 65 (empty -> .) ]
  ! (               [ reduce using rule 65 (empty -> .) ]

    line                           shift and go to state 24
    body                           shift and go to state 59
    empty                          shift and go to state 25
    declaration                    shift and go to state 26
    assignment                     shift and go to state 27
    if_clause                      shift and go to state 28
    for_loop                       shift and go to state 29
    expr_line                      shift and go to state 30
    return_expr                    shift and go to state 31
    printf_expr                    shift and go to state 32
    variable_or_pointer            shift and go to state 33
    expr_1                         shift and go to state 34
    array                          shift and go to state 35
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47

state 25

    (9) body -> empty .

    }               reduce using rule 9 (body -> empty .)
    TYPE            reduce using rule 9 (body -> empty .)
    IF              reduce using rule 9 (body -> empty .)
    FOR             reduce using rule 9 (body -> empty .)
    RETURN          reduce using rule 9 (body -> empty .)
    PRINTF          reduce using rule 9 (body -> empty .)
    *               reduce using rule 9 (body -> empty .)
    VARIABLE        reduce using rule 9 (body -> empty .)
    -               reduce using rule 9 (body -> empty .)
    INTEGER         reduce using rule 9 (body -> empty .)
    (               reduce using rule 9 (body -> empty .)


state 26

    (10) line -> declaration .

    TYPE            reduce using rule 10 (line -> declaration .)
    IF              reduce using rule 10 (line -> declaration .)
    FOR             reduce using rule 10 (line -> declaration .)
    RETURN          reduce using rule 10 (line -> declaration .)
    PRINTF          reduce using rule 10 (line -> declaration .)
    *               reduce using rule 10 (line -> declaration .)
    VARIABLE        reduce using rule 10 (line -> declaration .)
    -               reduce using rule 10 (line -> declaration .)
    INTEGER         reduce using rule 10 (line -> declaration .)
    (               reduce using rule 10 (line -> declaration .)
    }               reduce using rule 10 (line -> declaration .)


state 27

    (11) line -> assignment .

    TYPE            reduce using rule 11 (line -> assignment .)
    IF              reduce using rule 11 (line -> assignment .)
    FOR             reduce using rule 11 (line -> assignment .)
    RETURN          reduce using rule 11 (line -> assignment .)
    PRINTF          reduce using rule 11 (line -> assignment .)
    *               reduce using rule 11 (line -> assignment .)
    VARIABLE        reduce using rule 11 (line -> assignment .)
    -               reduce using rule 11 (line -> assignment .)
    INTEGER         reduce using rule 11 (line -> assignment .)
    (               reduce using rule 11 (line -> assignment .)
    }               reduce using rule 11 (line -> assignment .)


state 28

    (12) line -> if_clause .

    TYPE            reduce using rule 12 (line -> if_clause .)
    IF              reduce using rule 12 (line -> if_clause .)
    FOR             reduce using rule 12 (line -> if_clause .)
    RETURN          reduce using rule 12 (line -> if_clause .)
    PRINTF          reduce using rule 12 (line -> if_clause .)
    *               reduce using rule 12 (line -> if_clause .)
    VARIABLE        reduce using rule 12 (line -> if_clause .)
    -               reduce using rule 12 (line -> if_clause .)
    INTEGER         reduce using rule 12 (line -> if_clause .)
    (               reduce using rule 12 (line -> if_clause .)
    }               reduce using rule 12 (line -> if_clause .)


state 29

    (13) line -> for_loop .

    TYPE            reduce using rule 13 (line -> for_loop .)
    IF              reduce using rule 13 (line -> for_loop .)
    FOR             reduce using rule 13 (line -> for_loop .)
    RETURN          reduce using rule 13 (line -> for_loop .)
    PRINTF          reduce using rule 13 (line -> for_loop .)
    *               reduce using rule 13 (line -> for_loop .)
    VARIABLE        reduce using rule 13 (line -> for_loop .)
    -               reduce using rule 13 (line -> for_loop .)
    INTEGER         reduce using rule 13 (line -> for_loop .)
    (               reduce using rule 13 (line -> for_loop .)
    }               reduce using rule 13 (line -> for_loop .)


state 30

    (14) line -> expr_line .

    TYPE            reduce using rule 14 (line -> expr_line .)
    IF              reduce using rule 14 (line -> expr_line .)
    FOR             reduce using rule 14 (line -> expr_line .)
    RETURN          reduce using rule 14 (line -> expr_line .)
    PRINTF          reduce using rule 14 (line -> expr_line .)
    *               reduce using rule 14 (line -> expr_line .)
    VARIABLE        reduce using rule 14 (line -> expr_line .)
    -               reduce using rule 14 (line -> expr_line .)
    INTEGER         reduce using rule 14 (line -> expr_line .)
    (               reduce using rule 14 (line -> expr_line .)
    }               reduce using rule 14 (line -> expr_line .)


state 31

    (15) line -> return_expr .

    TYPE            reduce using rule 15 (line -> return_expr .)
    IF              reduce using rule 15 (line -> return_expr .)
    FOR             reduce using rule 15 (line -> return_expr .)
    RETURN          reduce using rule 15 (line -> return_expr .)
    PRINTF          reduce using rule 15 (line -> return_expr .)
    *               reduce using rule 15 (line -> return_expr .)
    VARIABLE        reduce using rule 15 (line -> return_expr .)
    -               reduce using rule 15 (line -> return_expr .)
    INTEGER         reduce using rule 15 (line -> return_expr .)
    (               reduce using rule 15 (line -> return_expr .)
    }               reduce using rule 15 (line -> return_expr .)


state 32

    (16) line -> printf_expr .

    TYPE            reduce using rule 16 (line -> printf_expr .)
    IF              reduce using rule 16 (line -> printf_expr .)
    FOR             reduce using rule 16 (line -> printf_expr .)
    RETURN          reduce using rule 16 (line -> printf_expr .)
    PRINTF          reduce using rule 16 (line -> printf_expr .)
    *               reduce using rule 16 (line -> printf_expr .)
    VARIABLE        reduce using rule 16 (line -> printf_expr .)
    -               reduce using rule 16 (line -> printf_expr .)
    INTEGER         reduce using rule 16 (line -> printf_expr .)
    (               reduce using rule 16 (line -> printf_expr .)
    }               reduce using rule 16 (line -> printf_expr .)


state 33

    (23) assignment -> variable_or_pointer . = expr_1 ;
    (25) assignment -> variable_or_pointer . = error ;
    (27) assignment -> variable_or_pointer . = & VARIABLE ;
    (50) expr_5 -> variable_or_pointer . INCR
    (53) expr_6 -> variable_or_pointer .

    =               shift and go to state 60
    INCR            shift and go to state 61
    *               reduce using rule 53 (expr_6 -> variable_or_pointer .)
    /               reduce using rule 53 (expr_6 -> variable_or_pointer .)
    PLUS            reduce using rule 53 (expr_6 -> variable_or_pointer .)
    -               reduce using rule 53 (expr_6 -> variable_or_pointer .)
    >               reduce using rule 53 (expr_6 -> variable_or_pointer .)
    <               reduce using rule 53 (expr_6 -> variable_or_pointer .)
    ;               reduce using rule 53 (expr_6 -> variable_or_pointer .)


state 34

    (31) expr_line -> expr_1 . ;

    ;               shift and go to state 62


state 35

    (24) assignment -> array . = expr_1 ;
    (26) assignment -> array . = error ;
    (28) assignment -> array . = & VARIABLE ;
    (55) expr_6 -> array .

    =               shift and go to state 63
    *               reduce using rule 55 (expr_6 -> array .)
    /               reduce using rule 55 (expr_6 -> array .)
    PLUS            reduce using rule 55 (expr_6 -> array .)
    -               reduce using rule 55 (expr_6 -> array .)
    >               reduce using rule 55 (expr_6 -> array .)
    <               reduce using rule 55 (expr_6 -> array .)
    ;               reduce using rule 55 (expr_6 -> array .)


state 36

    (57) if_clause -> IF . ( expr_1 ) { body }

    (               shift and go to state 64


state 37

    (58) for_loop -> FOR . ( assignment expr_1 ; expr_1 ) { body }
    (59) for_loop -> FOR . ( assignment expr_1 ; expr_1 ) body }
    (60) for_loop -> FOR . ( assignment expr_1 ; expr_1 ) { body

    (               shift and go to state 65


state 38

    (29) return_expr -> RETURN . expr_1 ;
    (30) return_expr -> RETURN . ;
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    ;               shift and go to state 67
    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_1                         shift and go to state 66
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 39

    (32) printf_expr -> PRINTF . ( STRING ) ;
    (33) printf_expr -> PRINTF . ( digit ) ;
    (34) printf_expr -> PRINTF . ( float ) ;

    (               shift and go to state 68


state 40

    (39) expr_1 -> expr_2 . > expr_1
    (40) expr_1 -> expr_2 . < expr_1
    (41) expr_1 -> expr_2 .

    >               shift and go to state 69
    <               shift and go to state 70
    ;               reduce using rule 41 (expr_1 -> expr_2 .)
    )               reduce using rule 41 (expr_1 -> expr_2 .)
    ]               reduce using rule 41 (expr_1 -> expr_2 .)
    ,               reduce using rule 41 (expr_1 -> expr_2 .)


state 41

    (42) expr_2 -> expr_3 . PLUS expr_2
    (43) expr_2 -> expr_3 . - expr_2
    (44) expr_2 -> expr_3 .

    PLUS            shift and go to state 71
    -               shift and go to state 72
    >               reduce using rule 44 (expr_2 -> expr_3 .)
    <               reduce using rule 44 (expr_2 -> expr_3 .)
    ;               reduce using rule 44 (expr_2 -> expr_3 .)
    )               reduce using rule 44 (expr_2 -> expr_3 .)
    ]               reduce using rule 44 (expr_2 -> expr_3 .)
    ,               reduce using rule 44 (expr_2 -> expr_3 .)


state 42

    (48) expr_4 -> - . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_5                         shift and go to state 73
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 43

    (45) expr_3 -> expr_4 . * expr_3
    (46) expr_3 -> expr_4 . / expr_3
    (47) expr_3 -> expr_4 .

    *               shift and go to state 74
    /               shift and go to state 75
    PLUS            reduce using rule 47 (expr_3 -> expr_4 .)
    -               reduce using rule 47 (expr_3 -> expr_4 .)
    >               reduce using rule 47 (expr_3 -> expr_4 .)
    <               reduce using rule 47 (expr_3 -> expr_4 .)
    ;               reduce using rule 47 (expr_3 -> expr_4 .)
    )               reduce using rule 47 (expr_3 -> expr_4 .)
    ]               reduce using rule 47 (expr_3 -> expr_4 .)
    ,               reduce using rule 47 (expr_3 -> expr_4 .)


state 44

    (49) expr_4 -> expr_5 .

    *               reduce using rule 49 (expr_4 -> expr_5 .)
    /               reduce using rule 49 (expr_4 -> expr_5 .)
    PLUS            reduce using rule 49 (expr_4 -> expr_5 .)
    -               reduce using rule 49 (expr_4 -> expr_5 .)
    >               reduce using rule 49 (expr_4 -> expr_5 .)
    <               reduce using rule 49 (expr_4 -> expr_5 .)
    ;               reduce using rule 49 (expr_4 -> expr_5 .)
    )               reduce using rule 49 (expr_4 -> expr_5 .)
    ]               reduce using rule 49 (expr_4 -> expr_5 .)
    ,               reduce using rule 49 (expr_4 -> expr_5 .)


state 45

    (51) expr_5 -> expr_6 .

    *               reduce using rule 51 (expr_5 -> expr_6 .)
    /               reduce using rule 51 (expr_5 -> expr_6 .)
    PLUS            reduce using rule 51 (expr_5 -> expr_6 .)
    -               reduce using rule 51 (expr_5 -> expr_6 .)
    >               reduce using rule 51 (expr_5 -> expr_6 .)
    <               reduce using rule 51 (expr_5 -> expr_6 .)
    ;               reduce using rule 51 (expr_5 -> expr_6 .)
    )               reduce using rule 51 (expr_5 -> expr_6 .)
    ]               reduce using rule 51 (expr_5 -> expr_6 .)
    ,               reduce using rule 51 (expr_5 -> expr_6 .)


state 46

    (52) expr_6 -> INTEGER .

    *               reduce using rule 52 (expr_6 -> INTEGER .)
    /               reduce using rule 52 (expr_6 -> INTEGER .)
    PLUS            reduce using rule 52 (expr_6 -> INTEGER .)
    -               reduce using rule 52 (expr_6 -> INTEGER .)
    >               reduce using rule 52 (expr_6 -> INTEGER .)
    <               reduce using rule 52 (expr_6 -> INTEGER .)
    ;               reduce using rule 52 (expr_6 -> INTEGER .)
    )               reduce using rule 52 (expr_6 -> INTEGER .)
    ]               reduce using rule 52 (expr_6 -> INTEGER .)
    ,               reduce using rule 52 (expr_6 -> INTEGER .)


state 47

    (54) expr_6 -> function_call .

    *               reduce using rule 54 (expr_6 -> function_call .)
    /               reduce using rule 54 (expr_6 -> function_call .)
    PLUS            reduce using rule 54 (expr_6 -> function_call .)
    -               reduce using rule 54 (expr_6 -> function_call .)
    >               reduce using rule 54 (expr_6 -> function_call .)
    <               reduce using rule 54 (expr_6 -> function_call .)
    ;               reduce using rule 54 (expr_6 -> function_call .)
    )               reduce using rule 54 (expr_6 -> function_call .)
    ]               reduce using rule 54 (expr_6 -> function_call .)
    ,               reduce using rule 54 (expr_6 -> function_call .)


state 48

    (17) declaration -> TYPE variable_list . ;
    (18) declaration -> TYPE variable_list .

    ;               shift and go to state 76
    TYPE            reduce using rule 18 (declaration -> TYPE variable_list .)
    IF              reduce using rule 18 (declaration -> TYPE variable_list .)
    FOR             reduce using rule 18 (declaration -> TYPE variable_list .)
    RETURN          reduce using rule 18 (declaration -> TYPE variable_list .)
    PRINTF          reduce using rule 18 (declaration -> TYPE variable_list .)
    *               reduce using rule 18 (declaration -> TYPE variable_list .)
    VARIABLE        reduce using rule 18 (declaration -> TYPE variable_list .)
    -               reduce using rule 18 (declaration -> TYPE variable_list .)
    INTEGER         reduce using rule 18 (declaration -> TYPE variable_list .)
    (               reduce using rule 18 (declaration -> TYPE variable_list .)
    }               reduce using rule 18 (declaration -> TYPE variable_list .)


state 49

    (19) variable_list -> variable_or_pointer .
    (21) variable_list -> variable_or_pointer . , variable_list

    ;               reduce using rule 19 (variable_list -> variable_or_pointer .)
    TYPE            reduce using rule 19 (variable_list -> variable_or_pointer .)
    IF              reduce using rule 19 (variable_list -> variable_or_pointer .)
    FOR             reduce using rule 19 (variable_list -> variable_or_pointer .)
    RETURN          reduce using rule 19 (variable_list -> variable_or_pointer .)
    PRINTF          reduce using rule 19 (variable_list -> variable_or_pointer .)
    *               reduce using rule 19 (variable_list -> variable_or_pointer .)
    VARIABLE        reduce using rule 19 (variable_list -> variable_or_pointer .)
    -               reduce using rule 19 (variable_list -> variable_or_pointer .)
    INTEGER         reduce using rule 19 (variable_list -> variable_or_pointer .)
    (               reduce using rule 19 (variable_list -> variable_or_pointer .)
    }               reduce using rule 19 (variable_list -> variable_or_pointer .)
    ,               shift and go to state 77


state 50

    (20) variable_list -> array .
    (22) variable_list -> array . , variable_list

    ;               reduce using rule 20 (variable_list -> array .)
    TYPE            reduce using rule 20 (variable_list -> array .)
    IF              reduce using rule 20 (variable_list -> array .)
    FOR             reduce using rule 20 (variable_list -> array .)
    RETURN          reduce using rule 20 (variable_list -> array .)
    PRINTF          reduce using rule 20 (variable_list -> array .)
    *               reduce using rule 20 (variable_list -> array .)
    VARIABLE        reduce using rule 20 (variable_list -> array .)
    -               reduce using rule 20 (variable_list -> array .)
    INTEGER         reduce using rule 20 (variable_list -> array .)
    (               reduce using rule 20 (variable_list -> array .)
    }               reduce using rule 20 (variable_list -> array .)
    ,               shift and go to state 78


state 51

    (38) variable_or_pointer -> VARIABLE .
    (64) array -> VARIABLE . [ expr_1 ]

    ,               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    ;               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    TYPE            reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    IF              reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    FOR             reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    RETURN          reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    PRINTF          reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    *               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    VARIABLE        reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    -               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    INTEGER         reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    (               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    }               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    =               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    [               shift and go to state 52


state 52

    (64) array -> VARIABLE [ . expr_1 ]
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_1                         shift and go to state 79
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 53

    (61) function_call -> VARIABLE ( . arguments_call )
    (62) arguments_call -> . expr_1
    (63) arguments_call -> . expr_1 , arguments_call
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    arguments_call                 shift and go to state 80
    expr_1                         shift and go to state 81
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 54

    (56) expr_6 -> ( expr_1 . )

    )               shift and go to state 82


state 55

    (50) expr_5 -> variable_or_pointer . INCR
    (53) expr_6 -> variable_or_pointer .

    INCR            shift and go to state 61
    *               reduce using rule 53 (expr_6 -> variable_or_pointer .)
    /               reduce using rule 53 (expr_6 -> variable_or_pointer .)
    PLUS            reduce using rule 53 (expr_6 -> variable_or_pointer .)
    -               reduce using rule 53 (expr_6 -> variable_or_pointer .)
    >               reduce using rule 53 (expr_6 -> variable_or_pointer .)
    <               reduce using rule 53 (expr_6 -> variable_or_pointer .)
    )               reduce using rule 53 (expr_6 -> variable_or_pointer .)
    ;               reduce using rule 53 (expr_6 -> variable_or_pointer .)
    ]               reduce using rule 53 (expr_6 -> variable_or_pointer .)
    ,               reduce using rule 53 (expr_6 -> variable_or_pointer .)


state 56

    (38) variable_or_pointer -> VARIABLE .
    (61) function_call -> VARIABLE . ( arguments_call )
    (64) array -> VARIABLE . [ expr_1 ]

    INCR            reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    *               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    /               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    PLUS            reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    -               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    >               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    <               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    )               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    ;               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    ]               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    ,               reduce using rule 38 (variable_or_pointer -> VARIABLE .)
    (               shift and go to state 53
    [               shift and go to state 52


state 57

    (55) expr_6 -> array .

    *               reduce using rule 55 (expr_6 -> array .)
    /               reduce using rule 55 (expr_6 -> array .)
    PLUS            reduce using rule 55 (expr_6 -> array .)
    -               reduce using rule 55 (expr_6 -> array .)
    >               reduce using rule 55 (expr_6 -> array .)
    <               reduce using rule 55 (expr_6 -> array .)
    )               reduce using rule 55 (expr_6 -> array .)
    ;               reduce using rule 55 (expr_6 -> array .)
    ]               reduce using rule 55 (expr_6 -> array .)
    ,               reduce using rule 55 (expr_6 -> array .)


state 58

    (3) function -> TYPE VARIABLE ( arguments ) { body } .

    TYPE            reduce using rule 3 (function -> TYPE VARIABLE ( arguments ) { body } .)
    $end            reduce using rule 3 (function -> TYPE VARIABLE ( arguments ) { body } .)


state 59

    (8) body -> line body .

    }               reduce using rule 8 (body -> line body .)
    TYPE            reduce using rule 8 (body -> line body .)
    IF              reduce using rule 8 (body -> line body .)
    FOR             reduce using rule 8 (body -> line body .)
    RETURN          reduce using rule 8 (body -> line body .)
    PRINTF          reduce using rule 8 (body -> line body .)
    *               reduce using rule 8 (body -> line body .)
    VARIABLE        reduce using rule 8 (body -> line body .)
    -               reduce using rule 8 (body -> line body .)
    INTEGER         reduce using rule 8 (body -> line body .)
    (               reduce using rule 8 (body -> line body .)


state 60

    (23) assignment -> variable_or_pointer = . expr_1 ;
    (25) assignment -> variable_or_pointer = . error ;
    (27) assignment -> variable_or_pointer = . & VARIABLE ;
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    error           shift and go to state 84
    &               shift and go to state 85
    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    variable_or_pointer            shift and go to state 55
    expr_1                         shift and go to state 83
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 61

    (50) expr_5 -> variable_or_pointer INCR .

    *               reduce using rule 50 (expr_5 -> variable_or_pointer INCR .)
    /               reduce using rule 50 (expr_5 -> variable_or_pointer INCR .)
    PLUS            reduce using rule 50 (expr_5 -> variable_or_pointer INCR .)
    -               reduce using rule 50 (expr_5 -> variable_or_pointer INCR .)
    >               reduce using rule 50 (expr_5 -> variable_or_pointer INCR .)
    <               reduce using rule 50 (expr_5 -> variable_or_pointer INCR .)
    ;               reduce using rule 50 (expr_5 -> variable_or_pointer INCR .)
    )               reduce using rule 50 (expr_5 -> variable_or_pointer INCR .)
    ]               reduce using rule 50 (expr_5 -> variable_or_pointer INCR .)
    ,               reduce using rule 50 (expr_5 -> variable_or_pointer INCR .)


state 62

    (31) expr_line -> expr_1 ; .

    TYPE            reduce using rule 31 (expr_line -> expr_1 ; .)
    IF              reduce using rule 31 (expr_line -> expr_1 ; .)
    FOR             reduce using rule 31 (expr_line -> expr_1 ; .)
    RETURN          reduce using rule 31 (expr_line -> expr_1 ; .)
    PRINTF          reduce using rule 31 (expr_line -> expr_1 ; .)
    *               reduce using rule 31 (expr_line -> expr_1 ; .)
    VARIABLE        reduce using rule 31 (expr_line -> expr_1 ; .)
    -               reduce using rule 31 (expr_line -> expr_1 ; .)
    INTEGER         reduce using rule 31 (expr_line -> expr_1 ; .)
    (               reduce using rule 31 (expr_line -> expr_1 ; .)
    }               reduce using rule 31 (expr_line -> expr_1 ; .)


state 63

    (24) assignment -> array = . expr_1 ;
    (26) assignment -> array = . error ;
    (28) assignment -> array = . & VARIABLE ;
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    error           shift and go to state 87
    &               shift and go to state 88
    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    array                          shift and go to state 57
    expr_1                         shift and go to state 86
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47

state 64

    (57) if_clause -> IF ( . expr_1 ) { body }
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_1                         shift and go to state 89
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 65

    (58) for_loop -> FOR ( . assignment expr_1 ; expr_1 ) { body }
    (59) for_loop -> FOR ( . assignment expr_1 ; expr_1 ) body }
    (60) for_loop -> FOR ( . assignment expr_1 ; expr_1 ) { body
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = error ;
    (26) assignment -> . array = error ;
    (27) assignment -> . variable_or_pointer = & VARIABLE ;
    (28) assignment -> . array = & VARIABLE ;
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (64) array -> . VARIABLE [ expr_1 ]

    *               shift and go to state 12
    VARIABLE        shift and go to state 51

    assignment                     shift and go to state 90
    variable_or_pointer            shift and go to state 91
    array                          shift and go to state 92

state 66

    (29) return_expr -> RETURN expr_1 . ;

    ;               shift and go to state 93


state 67

    (30) return_expr -> RETURN ; .

    TYPE            reduce using rule 30 (return_expr -> RETURN ; .)
    IF              reduce using rule 30 (return_expr -> RETURN ; .)
    FOR             reduce using rule 30 (return_expr -> RETURN ; .)
    RETURN          reduce using rule 30 (return_expr -> RETURN ; .)
    PRINTF          reduce using rule 30 (return_expr -> RETURN ; .)
    *               reduce using rule 30 (return_expr -> RETURN ; .)
    VARIABLE        reduce using rule 30 (return_expr -> RETURN ; .)
    -               reduce using rule 30 (return_expr -> RETURN ; .)
    INTEGER         reduce using rule 30 (return_expr -> RETURN ; .)
    (               reduce using rule 30 (return_expr -> RETURN ; .)
    }               reduce using rule 30 (return_expr -> RETURN ; .)


state 68

    (32) printf_expr -> PRINTF ( . STRING ) ;
    (33) printf_expr -> PRINTF ( . digit ) ;
    (34) printf_expr -> PRINTF ( . float ) ;
    (35) digit -> . DIGIT_STRING , expr_1
    (36) float -> . FLOAT_STRING , expr_1

    STRING          shift and go to state 94
    DIGIT_STRING    shift and go to state 97
    FLOAT_STRING    shift and go to state 98

    digit                          shift and go to state 95
    float                          shift and go to state 96

state 69

    (39) expr_1 -> expr_2 > . expr_1
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_2                         shift and go to state 40
    expr_1                         shift and go to state 99
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 70

    (40) expr_1 -> expr_2 < . expr_1
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_2                         shift and go to state 40
    expr_1                         shift and go to state 100
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 71

    (42) expr_2 -> expr_3 PLUS . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_3                         shift and go to state 41
    expr_2                         shift and go to state 101
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 72

    (43) expr_2 -> expr_3 - . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_3                         shift and go to state 41
    expr_2                         shift and go to state 102
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 73

    (48) expr_4 -> - expr_5 .

    *               reduce using rule 48 (expr_4 -> - expr_5 .)
    /               reduce using rule 48 (expr_4 -> - expr_5 .)
    PLUS            reduce using rule 48 (expr_4 -> - expr_5 .)
    -               reduce using rule 48 (expr_4 -> - expr_5 .)
    >               reduce using rule 48 (expr_4 -> - expr_5 .)
    <               reduce using rule 48 (expr_4 -> - expr_5 .)
    ;               reduce using rule 48 (expr_4 -> - expr_5 .)
    )               reduce using rule 48 (expr_4 -> - expr_5 .)
    ]               reduce using rule 48 (expr_4 -> - expr_5 .)
    ,               reduce using rule 48 (expr_4 -> - expr_5 .)


state 74

    (45) expr_3 -> expr_4 * . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_4                         shift and go to state 43
    expr_3                         shift and go to state 103
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 75

    (46) expr_3 -> expr_4 / . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_4                         shift and go to state 43
    expr_3                         shift and go to state 104
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 76

    (17) declaration -> TYPE variable_list ; .

    TYPE            reduce using rule 17 (declaration -> TYPE variable_list ; .)
    IF              reduce using rule 17 (declaration -> TYPE variable_list ; .)
    FOR             reduce using rule 17 (declaration -> TYPE variable_list ; .)
    RETURN          reduce using rule 17 (declaration -> TYPE variable_list ; .)
    PRINTF          reduce using rule 17 (declaration -> TYPE variable_list ; .)
    *               reduce using rule 17 (declaration -> TYPE variable_list ; .)
    VARIABLE        reduce using rule 17 (declaration -> TYPE variable_list ; .)
    -               reduce using rule 17 (declaration -> TYPE variable_list ; .)
    INTEGER         reduce using rule 17 (declaration -> TYPE variable_list ; .)
    (               reduce using rule 17 (declaration -> TYPE variable_list ; .)
    }               reduce using rule 17 (declaration -> TYPE variable_list ; .)


state 77

    (21) variable_list -> variable_or_pointer , . variable_list
    (19) variable_list -> . variable_or_pointer
    (20) variable_list -> . array
    (21) variable_list -> . variable_or_pointer , variable_list
    (22) variable_list -> . array , variable_list
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (64) array -> . VARIABLE [ expr_1 ]

    *               shift and go to state 12
    VARIABLE        shift and go to state 51

    variable_or_pointer            shift and go to state 49
    variable_list                  shift and go to state 105
    array                          shift and go to state 50

state 78

    (22) variable_list -> array , . variable_list
    (19) variable_list -> . variable_or_pointer
    (20) variable_list -> . array
    (21) variable_list -> . variable_or_pointer , variable_list
    (22) variable_list -> . array , variable_list
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (64) array -> . VARIABLE [ expr_1 ]

    *               shift and go to state 12
    VARIABLE        shift and go to state 51

    array                          shift and go to state 50
    variable_list                  shift and go to state 106
    variable_or_pointer            shift and go to state 49

state 79

    (64) array -> VARIABLE [ expr_1 . ]

    ]               shift and go to state 107


state 80

    (61) function_call -> VARIABLE ( arguments_call . )

    )               shift and go to state 108


state 81

    (62) arguments_call -> expr_1 .
    (63) arguments_call -> expr_1 . , arguments_call

    )               reduce using rule 62 (arguments_call -> expr_1 .)
    ,               shift and go to state 109


state 82

    (56) expr_6 -> ( expr_1 ) .

    *               reduce using rule 56 (expr_6 -> ( expr_1 ) .)
    /               reduce using rule 56 (expr_6 -> ( expr_1 ) .)
    PLUS            reduce using rule 56 (expr_6 -> ( expr_1 ) .)
    -               reduce using rule 56 (expr_6 -> ( expr_1 ) .)
    >               reduce using rule 56 (expr_6 -> ( expr_1 ) .)
    <               reduce using rule 56 (expr_6 -> ( expr_1 ) .)
    ;               reduce using rule 56 (expr_6 -> ( expr_1 ) .)
    )               reduce using rule 56 (expr_6 -> ( expr_1 ) .)
    ]               reduce using rule 56 (expr_6 -> ( expr_1 ) .)
    ,               reduce using rule 56 (expr_6 -> ( expr_1 ) .)


state 83

    (23) assignment -> variable_or_pointer = expr_1 . ;

    ;               shift and go to state 110


state 84

    (25) assignment -> variable_or_pointer = error . ;

    ;               shift and go to state 111


state 85

    (27) assignment -> variable_or_pointer = & . VARIABLE ;

    VARIABLE        shift and go to state 112


state 86

    (24) assignment -> array = expr_1 . ;

    ;               shift and go to state 113


state 87

    (26) assignment -> array = error . ;

    ;               shift and go to state 114


state 88

    (28) assignment -> array = & . VARIABLE ;

    VARIABLE        shift and go to state 115


state 89

    (57) if_clause -> IF ( expr_1 . ) { body }

    )               shift and go to state 116


state 90

    (58) for_loop -> FOR ( assignment . expr_1 ; expr_1 ) { body }
    (59) for_loop -> FOR ( assignment . expr_1 ; expr_1 ) body }
    (60) for_loop -> FOR ( assignment . expr_1 ; expr_1 ) { body
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_1                         shift and go to state 117
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 91

    (23) assignment -> variable_or_pointer . = expr_1 ;
    (25) assignment -> variable_or_pointer . = error ;
    (27) assignment -> variable_or_pointer . = & VARIABLE ;

    =               shift and go to state 60


state 92

    (24) assignment -> array . = expr_1 ;
    (26) assignment -> array . = error ;
    (28) assignment -> array . = & VARIABLE ;

    =               shift and go to state 63


state 93

    (29) return_expr -> RETURN expr_1 ; .

    TYPE            reduce using rule 29 (return_expr -> RETURN expr_1 ; .)
    IF              reduce using rule 29 (return_expr -> RETURN expr_1 ; .)
    FOR             reduce using rule 29 (return_expr -> RETURN expr_1 ; .)
    RETURN          reduce using rule 29 (return_expr -> RETURN expr_1 ; .)
    PRINTF          reduce using rule 29 (return_expr -> RETURN expr_1 ; .)
    *               reduce using rule 29 (return_expr -> RETURN expr_1 ; .)
    VARIABLE        reduce using rule 29 (return_expr -> RETURN expr_1 ; .)
    -               reduce using rule 29 (return_expr -> RETURN expr_1 ; .)
    INTEGER         reduce using rule 29 (return_expr -> RETURN expr_1 ; .)
    (               reduce using rule 29 (return_expr -> RETURN expr_1 ; .)
    }               reduce using rule 29 (return_expr -> RETURN expr_1 ; .)


state 94

    (32) printf_expr -> PRINTF ( STRING . ) ;

    )               shift and go to state 118


state 95

    (33) printf_expr -> PRINTF ( digit . ) ;

    )               shift and go to state 119


state 96

    (34) printf_expr -> PRINTF ( float . ) ;

    )               shift and go to state 120


state 97

    (35) digit -> DIGIT_STRING . , expr_1

    ,               shift and go to state 121


state 98

    (36) float -> FLOAT_STRING . , expr_1

    ,               shift and go to state 122


state 99

    (39) expr_1 -> expr_2 > expr_1 .

    ;               reduce using rule 39 (expr_1 -> expr_2 > expr_1 .)
    )               reduce using rule 39 (expr_1 -> expr_2 > expr_1 .)
    ]               reduce using rule 39 (expr_1 -> expr_2 > expr_1 .)
    ,               reduce using rule 39 (expr_1 -> expr_2 > expr_1 .)


state 100

    (40) expr_1 -> expr_2 < expr_1 .

    ;               reduce using rule 40 (expr_1 -> expr_2 < expr_1 .)
    )               reduce using rule 40 (expr_1 -> expr_2 < expr_1 .)
    ]               reduce using rule 40 (expr_1 -> expr_2 < expr_1 .)
    ,               reduce using rule 40 (expr_1 -> expr_2 < expr_1 .)


state 101

    (42) expr_2 -> expr_3 PLUS expr_2 .

    >               reduce using rule 42 (expr_2 -> expr_3 PLUS expr_2 .)
    <               reduce using rule 42 (expr_2 -> expr_3 PLUS expr_2 .)
    ;               reduce using rule 42 (expr_2 -> expr_3 PLUS expr_2 .)
    )               reduce using rule 42 (expr_2 -> expr_3 PLUS expr_2 .)
    ]               reduce using rule 42 (expr_2 -> expr_3 PLUS expr_2 .)
    ,               reduce using rule 42 (expr_2 -> expr_3 PLUS expr_2 .)


state 102

    (43) expr_2 -> expr_3 - expr_2 .

    >               reduce using rule 43 (expr_2 -> expr_3 - expr_2 .)
    <               reduce using rule 43 (expr_2 -> expr_3 - expr_2 .)
    ;               reduce using rule 43 (expr_2 -> expr_3 - expr_2 .)
    )               reduce using rule 43 (expr_2 -> expr_3 - expr_2 .)
    ]               reduce using rule 43 (expr_2 -> expr_3 - expr_2 .)
    ,               reduce using rule 43 (expr_2 -> expr_3 - expr_2 .)


state 103

    (45) expr_3 -> expr_4 * expr_3 .

    PLUS            reduce using rule 45 (expr_3 -> expr_4 * expr_3 .)
    -               reduce using rule 45 (expr_3 -> expr_4 * expr_3 .)
    >               reduce using rule 45 (expr_3 -> expr_4 * expr_3 .)
    <               reduce using rule 45 (expr_3 -> expr_4 * expr_3 .)
    ;               reduce using rule 45 (expr_3 -> expr_4 * expr_3 .)
    )               reduce using rule 45 (expr_3 -> expr_4 * expr_3 .)
    ]               reduce using rule 45 (expr_3 -> expr_4 * expr_3 .)
    ,               reduce using rule 45 (expr_3 -> expr_4 * expr_3 .)


state 104

    (46) expr_3 -> expr_4 / expr_3 .

    PLUS            reduce using rule 46 (expr_3 -> expr_4 / expr_3 .)
    -               reduce using rule 46 (expr_3 -> expr_4 / expr_3 .)
    >               reduce using rule 46 (expr_3 -> expr_4 / expr_3 .)
    <               reduce using rule 46 (expr_3 -> expr_4 / expr_3 .)
    ;               reduce using rule 46 (expr_3 -> expr_4 / expr_3 .)
    )               reduce using rule 46 (expr_3 -> expr_4 / expr_3 .)
    ]               reduce using rule 46 (expr_3 -> expr_4 / expr_3 .)
    ,               reduce using rule 46 (expr_3 -> expr_4 / expr_3 .)


state 105

    (21) variable_list -> variable_or_pointer , variable_list .

    ;               reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    TYPE            reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    IF              reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    FOR             reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    RETURN          reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    PRINTF          reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    *               reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    VARIABLE        reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    -               reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    INTEGER         reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    (               reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    }               reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)


state 106

    (22) variable_list -> array , variable_list .

    ;               reduce using rule 22 (variable_list -> array , variable_list .)
    TYPE            reduce using rule 22 (variable_list -> array , variable_list .)
    IF              reduce using rule 22 (variable_list -> array , variable_list .)
    FOR             reduce using rule 22 (variable_list -> array , variable_list .)
    RETURN          reduce using rule 22 (variable_list -> array , variable_list .)
    PRINTF          reduce using rule 22 (variable_list -> array , variable_list .)
    *               reduce using rule 22 (variable_list -> array , variable_list .)
    VARIABLE        reduce using rule 22 (variable_list -> array , variable_list .)
    -               reduce using rule 22 (variable_list -> array , variable_list .)
    INTEGER         reduce using rule 22 (variable_list -> array , variable_list .)
    (               reduce using rule 22 (variable_list -> array , variable_list .)
    }               reduce using rule 22 (variable_list -> array , variable_list .)


state 107

    (64) array -> VARIABLE [ expr_1 ] .

    =               reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    *               reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    /               reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    PLUS            reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    -               reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    >               reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    <               reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    ;               reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    ,               reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    TYPE            reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    IF              reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    FOR             reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    RETURN          reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    PRINTF          reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    VARIABLE        reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    INTEGER         reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    (               reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    }               reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    )               reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)
    ]               reduce using rule 64 (array -> VARIABLE [ expr_1 ] .)


state 108

    (61) function_call -> VARIABLE ( arguments_call ) .

    *               reduce using rule 61 (function_call -> VARIABLE ( arguments_call ) .)
    /               reduce using rule 61 (function_call -> VARIABLE ( arguments_call ) .)
    PLUS            reduce using rule 61 (function_call -> VARIABLE ( arguments_call ) .)
    -               reduce using rule 61 (function_call -> VARIABLE ( arguments_call ) .)
    >               reduce using rule 61 (function_call -> VARIABLE ( arguments_call ) .)
    <               reduce using rule 61 (function_call -> VARIABLE ( arguments_call ) .)
    ;               reduce using rule 61 (function_call -> VARIABLE ( arguments_call ) .)
    )               reduce using rule 61 (function_call -> VARIABLE ( arguments_call ) .)
    ]               reduce using rule 61 (function_call -> VARIABLE ( arguments_call ) .)
    ,               reduce using rule 61 (function_call -> VARIABLE ( arguments_call ) .)


state 109

    (63) arguments_call -> expr_1 , . arguments_call
    (62) arguments_call -> . expr_1
    (63) arguments_call -> . expr_1 , arguments_call
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_1                         shift and go to state 81
    arguments_call                 shift and go to state 123
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 110

    (23) assignment -> variable_or_pointer = expr_1 ; .

    TYPE            reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    IF              reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    FOR             reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    RETURN          reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    PRINTF          reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    *               reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    VARIABLE        reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    -               reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    INTEGER         reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    (               reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    }               reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)


state 111

    (25) assignment -> variable_or_pointer = error ; .

    TYPE            reduce using rule 25 (assignment -> variable_or_pointer = error ; .)
    IF              reduce using rule 25 (assignment -> variable_or_pointer = error ; .)
    FOR             reduce using rule 25 (assignment -> variable_or_pointer = error ; .)
    RETURN          reduce using rule 25 (assignment -> variable_or_pointer = error ; .)
    PRINTF          reduce using rule 25 (assignment -> variable_or_pointer = error ; .)
    *               reduce using rule 25 (assignment -> variable_or_pointer = error ; .)
    VARIABLE        reduce using rule 25 (assignment -> variable_or_pointer = error ; .)
    -               reduce using rule 25 (assignment -> variable_or_pointer = error ; .)
    INTEGER         reduce using rule 25 (assignment -> variable_or_pointer = error ; .)
    (               reduce using rule 25 (assignment -> variable_or_pointer = error ; .)
    }               reduce using rule 25 (assignment -> variable_or_pointer = error ; .)


state 112

    (27) assignment -> variable_or_pointer = & VARIABLE . ;

    ;               shift and go to state 124


state 113

    (24) assignment -> array = expr_1 ; .

    TYPE            reduce using rule 24 (assignment -> array = expr_1 ; .)
    IF              reduce using rule 24 (assignment -> array = expr_1 ; .)
    FOR             reduce using rule 24 (assignment -> array = expr_1 ; .)
    RETURN          reduce using rule 24 (assignment -> array = expr_1 ; .)
    PRINTF          reduce using rule 24 (assignment -> array = expr_1 ; .)
    *               reduce using rule 24 (assignment -> array = expr_1 ; .)
    VARIABLE        reduce using rule 24 (assignment -> array = expr_1 ; .)
    -               reduce using rule 24 (assignment -> array = expr_1 ; .)
    INTEGER         reduce using rule 24 (assignment -> array = expr_1 ; .)
    (               reduce using rule 24 (assignment -> array = expr_1 ; .)
    }               reduce using rule 24 (assignment -> array = expr_1 ; .)


state 114

    (26) assignment -> array = error ; .

    TYPE            reduce using rule 26 (assignment -> array = error ; .)
    IF              reduce using rule 26 (assignment -> array = error ; .)
    FOR             reduce using rule 26 (assignment -> array = error ; .)
    RETURN          reduce using rule 26 (assignment -> array = error ; .)
    PRINTF          reduce using rule 26 (assignment -> array = error ; .)
    *               reduce using rule 26 (assignment -> array = error ; .)
    VARIABLE        reduce using rule 26 (assignment -> array = error ; .)
    -               reduce using rule 26 (assignment -> array = error ; .)
    INTEGER         reduce using rule 26 (assignment -> array = error ; .)
    (               reduce using rule 26 (assignment -> array = error ; .)
    }               reduce using rule 26 (assignment -> array = error ; .)


state 115

    (28) assignment -> array = & VARIABLE . ;

    ;               shift and go to state 125


state 116

    (57) if_clause -> IF ( expr_1 ) . { body }

    {               shift and go to state 126


state 117

    (58) for_loop -> FOR ( assignment expr_1 . ; expr_1 ) { body }
    (59) for_loop -> FOR ( assignment expr_1 . ; expr_1 ) body }
    (60) for_loop -> FOR ( assignment expr_1 . ; expr_1 ) { body

    ;               shift and go to state 127


state 118

    (32) printf_expr -> PRINTF ( STRING ) . ;

    ;               shift and go to state 128


state 119

    (33) printf_expr -> PRINTF ( digit ) . ;

    ;               shift and go to state 129


state 120

    (34) printf_expr -> PRINTF ( float ) . ;

    ;               shift and go to state 130


state 121

    (35) digit -> DIGIT_STRING , . expr_1
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_1                         shift and go to state 131
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 122

    (36) float -> FLOAT_STRING , . expr_1
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_1                         shift and go to state 132
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 123

    (63) arguments_call -> expr_1 , arguments_call .

    )               reduce using rule 63 (arguments_call -> expr_1 , arguments_call .)


state 124

    (27) assignment -> variable_or_pointer = & VARIABLE ; .

    TYPE            reduce using rule 27 (assignment -> variable_or_pointer = & VARIABLE ; .)
    IF              reduce using rule 27 (assignment -> variable_or_pointer = & VARIABLE ; .)
    FOR             reduce using rule 27 (assignment -> variable_or_pointer = & VARIABLE ; .)
    RETURN          reduce using rule 27 (assignment -> variable_or_pointer = & VARIABLE ; .)
    PRINTF          reduce using rule 27 (assignment -> variable_or_pointer = & VARIABLE ; .)
    *               reduce using rule 27 (assignment -> variable_or_pointer = & VARIABLE ; .)
    VARIABLE        reduce using rule 27 (assignment -> variable_or_pointer = & VARIABLE ; .)
    -               reduce using rule 27 (assignment -> variable_or_pointer = & VARIABLE ; .)
    INTEGER         reduce using rule 27 (assignment -> variable_or_pointer = & VARIABLE ; .)
    (               reduce using rule 27 (assignment -> variable_or_pointer = & VARIABLE ; .)
    }               reduce using rule 27 (assignment -> variable_or_pointer = & VARIABLE ; .)


state 125

    (28) assignment -> array = & VARIABLE ; .

    TYPE            reduce using rule 28 (assignment -> array = & VARIABLE ; .)
    IF              reduce using rule 28 (assignment -> array = & VARIABLE ; .)
    FOR             reduce using rule 28 (assignment -> array = & VARIABLE ; .)
    RETURN          reduce using rule 28 (assignment -> array = & VARIABLE ; .)
    PRINTF          reduce using rule 28 (assignment -> array = & VARIABLE ; .)
    *               reduce using rule 28 (assignment -> array = & VARIABLE ; .)
    VARIABLE        reduce using rule 28 (assignment -> array = & VARIABLE ; .)
    -               reduce using rule 28 (assignment -> array = & VARIABLE ; .)
    INTEGER         reduce using rule 28 (assignment -> array = & VARIABLE ; .)
    (               reduce using rule 28 (assignment -> array = & VARIABLE ; .)
    }               reduce using rule 28 (assignment -> array = & VARIABLE ; .)


state 126

    (57) if_clause -> IF ( expr_1 ) { . body }
    (8) body -> . line body
    (9) body -> . empty
    (10) line -> . declaration
    (11) line -> . assignment
    (12) line -> . if_clause
    (13) line -> . for_loop
    (14) line -> . expr_line
    (15) line -> . return_expr
    (16) line -> . printf_expr
    (65) empty -> .
    (17) declaration -> . TYPE variable_list ;
    (18) declaration -> . TYPE variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = error ;
    (26) assignment -> . array = error ;
    (27) assignment -> . variable_or_pointer = & VARIABLE ;
    (28) assignment -> . array = & VARIABLE ;
    (57) if_clause -> . IF ( expr_1 ) { body }
    (58) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (59) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (60) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (31) expr_line -> . expr_1 ;
    (29) return_expr -> . RETURN expr_1 ;
    (30) return_expr -> . RETURN ;
    (32) printf_expr -> . PRINTF ( STRING ) ;
    (33) printf_expr -> . PRINTF ( digit ) ;
    (34) printf_expr -> . PRINTF ( float ) ;
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (64) array -> . VARIABLE [ expr_1 ]
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )

    }               reduce using rule 65 (empty -> .)
    TYPE            shift and go to state 20
    IF              shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    PRINTF          shift and go to state 39
    *               shift and go to state 12
    VARIABLE        shift and go to state 21
    -               shift and go to state 42
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_1                         shift and go to state 34
    body                           shift and go to state 133
    line                           shift and go to state 24
    empty                          shift and go to state 25
    declaration                    shift and go to state 26
    assignment                     shift and go to state 27
    if_clause                      shift and go to state 28
    for_loop                       shift and go to state 29
    expr_line                      shift and go to state 30
    return_expr                    shift and go to state 31
    printf_expr                    shift and go to state 32
    variable_or_pointer            shift and go to state 33
    array                          shift and go to state 35
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47

state 127

    (58) for_loop -> FOR ( assignment expr_1 ; . expr_1 ) { body }
    (59) for_loop -> FOR ( assignment expr_1 ; . expr_1 ) body }
    (60) for_loop -> FOR ( assignment expr_1 ; . expr_1 ) { body
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )
    (64) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 42
    *               shift and go to state 12
    VARIABLE        shift and go to state 56
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    expr_1                         shift and go to state 134
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    variable_or_pointer            shift and go to state 55
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47
    array                          shift and go to state 57

state 128

    (32) printf_expr -> PRINTF ( STRING ) ; .

    TYPE            reduce using rule 32 (printf_expr -> PRINTF ( STRING ) ; .)
    IF              reduce using rule 32 (printf_expr -> PRINTF ( STRING ) ; .)
    FOR             reduce using rule 32 (printf_expr -> PRINTF ( STRING ) ; .)
    RETURN          reduce using rule 32 (printf_expr -> PRINTF ( STRING ) ; .)
    PRINTF          reduce using rule 32 (printf_expr -> PRINTF ( STRING ) ; .)
    *               reduce using rule 32 (printf_expr -> PRINTF ( STRING ) ; .)
    VARIABLE        reduce using rule 32 (printf_expr -> PRINTF ( STRING ) ; .)
    -               reduce using rule 32 (printf_expr -> PRINTF ( STRING ) ; .)
    INTEGER         reduce using rule 32 (printf_expr -> PRINTF ( STRING ) ; .)
    (               reduce using rule 32 (printf_expr -> PRINTF ( STRING ) ; .)
    }               reduce using rule 32 (printf_expr -> PRINTF ( STRING ) ; .)


state 129

    (33) printf_expr -> PRINTF ( digit ) ; .

    TYPE            reduce using rule 33 (printf_expr -> PRINTF ( digit ) ; .)
    IF              reduce using rule 33 (printf_expr -> PRINTF ( digit ) ; .)
    FOR             reduce using rule 33 (printf_expr -> PRINTF ( digit ) ; .)
    RETURN          reduce using rule 33 (printf_expr -> PRINTF ( digit ) ; .)
    PRINTF          reduce using rule 33 (printf_expr -> PRINTF ( digit ) ; .)
    *               reduce using rule 33 (printf_expr -> PRINTF ( digit ) ; .)
    VARIABLE        reduce using rule 33 (printf_expr -> PRINTF ( digit ) ; .)
    -               reduce using rule 33 (printf_expr -> PRINTF ( digit ) ; .)
    INTEGER         reduce using rule 33 (printf_expr -> PRINTF ( digit ) ; .)
    (               reduce using rule 33 (printf_expr -> PRINTF ( digit ) ; .)
    }               reduce using rule 33 (printf_expr -> PRINTF ( digit ) ; .)


state 130

    (34) printf_expr -> PRINTF ( float ) ; .

    TYPE            reduce using rule 34 (printf_expr -> PRINTF ( float ) ; .)
    IF              reduce using rule 34 (printf_expr -> PRINTF ( float ) ; .)
    FOR             reduce using rule 34 (printf_expr -> PRINTF ( float ) ; .)
    RETURN          reduce using rule 34 (printf_expr -> PRINTF ( float ) ; .)
    PRINTF          reduce using rule 34 (printf_expr -> PRINTF ( float ) ; .)
    *               reduce using rule 34 (printf_expr -> PRINTF ( float ) ; .)
    VARIABLE        reduce using rule 34 (printf_expr -> PRINTF ( float ) ; .)
    -               reduce using rule 34 (printf_expr -> PRINTF ( float ) ; .)
    INTEGER         reduce using rule 34 (printf_expr -> PRINTF ( float ) ; .)
    (               reduce using rule 34 (printf_expr -> PRINTF ( float ) ; .)
    }               reduce using rule 34 (printf_expr -> PRINTF ( float ) ; .)


state 131

    (35) digit -> DIGIT_STRING , expr_1 .

    )               reduce using rule 35 (digit -> DIGIT_STRING , expr_1 .)


state 132

    (36) float -> FLOAT_STRING , expr_1 .

    )               reduce using rule 36 (float -> FLOAT_STRING , expr_1 .)


state 133

    (57) if_clause -> IF ( expr_1 ) { body . }

    }               shift and go to state 135


state 134

    (58) for_loop -> FOR ( assignment expr_1 ; expr_1 . ) { body }
    (59) for_loop -> FOR ( assignment expr_1 ; expr_1 . ) body }
    (60) for_loop -> FOR ( assignment expr_1 ; expr_1 . ) { body

    )               shift and go to state 136


state 135

    (57) if_clause -> IF ( expr_1 ) { body } .

    TYPE            reduce using rule 57 (if_clause -> IF ( expr_1 ) { body } .)
    IF              reduce using rule 57 (if_clause -> IF ( expr_1 ) { body } .)
    FOR             reduce using rule 57 (if_clause -> IF ( expr_1 ) { body } .)
    RETURN          reduce using rule 57 (if_clause -> IF ( expr_1 ) { body } .)
    PRINTF          reduce using rule 57 (if_clause -> IF ( expr_1 ) { body } .)
    *               reduce using rule 57 (if_clause -> IF ( expr_1 ) { body } .)
    VARIABLE        reduce using rule 57 (if_clause -> IF ( expr_1 ) { body } .)
    -               reduce using rule 57 (if_clause -> IF ( expr_1 ) { body } .)
    INTEGER         reduce using rule 57 (if_clause -> IF ( expr_1 ) { body } .)
    (               reduce using rule 57 (if_clause -> IF ( expr_1 ) { body } .)
    }               reduce using rule 57 (if_clause -> IF ( expr_1 ) { body } .)


state 136

    (58) for_loop -> FOR ( assignment expr_1 ; expr_1 ) . { body }
    (59) for_loop -> FOR ( assignment expr_1 ; expr_1 ) . body }
    (60) for_loop -> FOR ( assignment expr_1 ; expr_1 ) . { body
    (8) body -> . line body
    (9) body -> . empty
    (10) line -> . declaration
    (11) line -> . assignment
    (12) line -> . if_clause
    (13) line -> . for_loop
    (14) line -> . expr_line
    (15) line -> . return_expr
    (16) line -> . printf_expr
    (65) empty -> .
    (17) declaration -> . TYPE variable_list ;
    (18) declaration -> . TYPE variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = error ;
    (26) assignment -> . array = error ;
    (27) assignment -> . variable_or_pointer = & VARIABLE ;
    (28) assignment -> . array = & VARIABLE ;
    (57) if_clause -> . IF ( expr_1 ) { body }
    (58) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (59) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (60) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (31) expr_line -> . expr_1 ;
    (29) return_expr -> . RETURN expr_1 ;
    (30) return_expr -> . RETURN ;
    (32) printf_expr -> . PRINTF ( STRING ) ;
    (33) printf_expr -> . PRINTF ( digit ) ;
    (34) printf_expr -> . PRINTF ( float ) ;
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (64) array -> . VARIABLE [ expr_1 ]
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )

    {               shift and go to state 137
    }               reduce using rule 65 (empty -> .)
    TYPE            shift and go to state 20
    IF              shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    PRINTF          shift and go to state 39
    *               shift and go to state 12
    VARIABLE        shift and go to state 21
    -               shift and go to state 42
    INTEGER         shift and go to state 46
    (               shift and go to state 22

    assignment                     shift and go to state 27
    expr_1                         shift and go to state 34
    body                           shift and go to state 138
    line                           shift and go to state 24
    empty                          shift and go to state 25
    declaration                    shift and go to state 26
    if_clause                      shift and go to state 28
    for_loop                       shift and go to state 29
    expr_line                      shift and go to state 30
    return_expr                    shift and go to state 31
    printf_expr                    shift and go to state 32
    variable_or_pointer            shift and go to state 33
    array                          shift and go to state 35
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47

state 137

    (58) for_loop -> FOR ( assignment expr_1 ; expr_1 ) { . body }
    (60) for_loop -> FOR ( assignment expr_1 ; expr_1 ) { . body
    (8) body -> . line body
    (9) body -> . empty
    (10) line -> . declaration
    (11) line -> . assignment
    (12) line -> . if_clause
    (13) line -> . for_loop
    (14) line -> . expr_line
    (15) line -> . return_expr
    (16) line -> . printf_expr
    (65) empty -> .
    (17) declaration -> . TYPE variable_list ;
    (18) declaration -> . TYPE variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = error ;
    (26) assignment -> . array = error ;
    (27) assignment -> . variable_or_pointer = & VARIABLE ;
    (28) assignment -> . array = & VARIABLE ;
    (57) if_clause -> . IF ( expr_1 ) { body }
    (58) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (59) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (60) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (31) expr_line -> . expr_1 ;
    (29) return_expr -> . RETURN expr_1 ;
    (30) return_expr -> . RETURN ;
    (32) printf_expr -> . PRINTF ( STRING ) ;
    (33) printf_expr -> . PRINTF ( digit ) ;
    (34) printf_expr -> . PRINTF ( float ) ;
    (37) variable_or_pointer -> . * VARIABLE
    (38) variable_or_pointer -> . VARIABLE
    (64) array -> . VARIABLE [ expr_1 ]
    (39) expr_1 -> . expr_2 > expr_1
    (40) expr_1 -> . expr_2 < expr_1
    (41) expr_1 -> . expr_2
    (42) expr_2 -> . expr_3 PLUS expr_2
    (43) expr_2 -> . expr_3 - expr_2
    (44) expr_2 -> . expr_3
    (45) expr_3 -> . expr_4 * expr_3
    (46) expr_3 -> . expr_4 / expr_3
    (47) expr_3 -> . expr_4
    (48) expr_4 -> . - expr_5
    (49) expr_4 -> . expr_5
    (50) expr_5 -> . variable_or_pointer INCR
    (51) expr_5 -> . expr_6
    (52) expr_6 -> . INTEGER
    (53) expr_6 -> . variable_or_pointer
    (54) expr_6 -> . function_call
    (55) expr_6 -> . array
    (56) expr_6 -> . ( expr_1 )
    (61) function_call -> . VARIABLE ( arguments_call )

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    }               reduce using rule 65 (empty -> .)
    TYPE            shift and go to state 20
    IF              shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    PRINTF          shift and go to state 39
    *               shift and go to state 12
    VARIABLE        shift and go to state 21
    -               shift and go to state 42
    INTEGER         shift and go to state 46
    (               shift and go to state 22

  ! TYPE            [ reduce using rule 65 (empty -> .) ]
  ! IF              [ reduce using rule 65 (empty -> .) ]
  ! FOR             [ reduce using rule 65 (empty -> .) ]
  ! RETURN          [ reduce using rule 65 (empty -> .) ]
  ! PRINTF          [ reduce using rule 65 (empty -> .) ]
  ! *               [ reduce using rule 65 (empty -> .) ]
  ! VARIABLE        [ reduce using rule 65 (empty -> .) ]
  ! -               [ reduce using rule 65 (empty -> .) ]
  ! INTEGER         [ reduce using rule 65 (empty -> .) ]
  ! (               [ reduce using rule 65 (empty -> .) ]

    assignment                     shift and go to state 27
    expr_1                         shift and go to state 34
    body                           shift and go to state 139
    line                           shift and go to state 24
    empty                          shift and go to state 25
    declaration                    shift and go to state 26
    if_clause                      shift and go to state 28
    for_loop                       shift and go to state 29
    expr_line                      shift and go to state 30
    return_expr                    shift and go to state 31
    printf_expr                    shift and go to state 32
    variable_or_pointer            shift and go to state 33
    array                          shift and go to state 35
    expr_2                         shift and go to state 40
    expr_3                         shift and go to state 41
    expr_4                         shift and go to state 43
    expr_5                         shift and go to state 44
    expr_6                         shift and go to state 45
    function_call                  shift and go to state 47

state 138

    (59) for_loop -> FOR ( assignment expr_1 ; expr_1 ) body . }

    }               shift and go to state 140


state 139

    (58) for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body . }
    (60) for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .

  ! shift/reduce conflict for } resolved as shift
    }               shift and go to state 141
    TYPE            reduce using rule 60 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    IF              reduce using rule 60 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    FOR             reduce using rule 60 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    RETURN          reduce using rule 60 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    PRINTF          reduce using rule 60 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    *               reduce using rule 60 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    VARIABLE        reduce using rule 60 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    -               reduce using rule 60 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    INTEGER         reduce using rule 60 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    (               reduce using rule 60 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)

  ! }               [ reduce using rule 60 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .) ]


state 140

    (59) for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .

    TYPE            reduce using rule 59 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    IF              reduce using rule 59 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    FOR             reduce using rule 59 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    RETURN          reduce using rule 59 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    PRINTF          reduce using rule 59 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    *               reduce using rule 59 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    VARIABLE        reduce using rule 59 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    -               reduce using rule 59 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    INTEGER         reduce using rule 59 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    (               reduce using rule 59 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    }               reduce using rule 59 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)


state 141

    (58) for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .

    TYPE            reduce using rule 58 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    IF              reduce using rule 58 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    FOR             reduce using rule 58 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    RETURN          reduce using rule 58 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    PRINTF          reduce using rule 58 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    *               reduce using rule 58 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    VARIABLE        reduce using rule 58 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    -               reduce using rule 58 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    INTEGER         reduce using rule 58 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    (               reduce using rule 58 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    }               reduce using rule 58 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TYPE in state 24 resolved as shift
WARNING: shift/reduce conflict for IF in state 24 resolved as shift
WARNING: shift/reduce conflict for FOR in state 24 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 24 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 24 resolved as shift
WARNING: shift/reduce conflict for * in state 24 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 24 resolved as shift
WARNING: shift/reduce conflict for - in state 24 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 24 resolved as shift
WARNING: shift/reduce conflict for ( in state 24 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 137 resolved as shift
WARNING: shift/reduce conflict for IF in state 137 resolved as shift
WARNING: shift/reduce conflict for FOR in state 137 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 137 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 137 resolved as shift
WARNING: shift/reduce conflict for * in state 137 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 137 resolved as shift
WARNING: shift/reduce conflict for - in state 137 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 137 resolved as shift
WARNING: shift/reduce conflict for ( in state 137 resolved as shift
WARNING: shift/reduce conflict for } in state 139 resolved as shift
