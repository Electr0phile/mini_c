Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> function_list
Rule 1     function_list -> function function_list
Rule 2     function_list -> empty
Rule 3     function -> type_func VARIABLE ( arguments ) { body }
Rule 4     arguments -> arguments_rec
Rule 5     arguments_rec -> type_var variable_or_pointer
Rule 6     arguments_rec -> type_var variable_or_pointer , arguments_rec
Rule 7     arguments -> VOID_TYPE
Rule 8     arguments -> empty
Rule 9     body -> line body
Rule 10    body -> empty
Rule 11    line -> declaration
Rule 12    line -> assignment
Rule 13    line -> if_clause
Rule 14    line -> for_loop
Rule 15    line -> expr_line
Rule 16    line -> return_expr
Rule 17    line -> printf_expr
Rule 18    declaration -> type_var variable_list ;
Rule 19    variable_list -> variable_or_pointer
Rule 20    variable_list -> array
Rule 21    variable_list -> variable_or_pointer , variable_list
Rule 22    variable_list -> array , variable_list
Rule 23    assignment -> variable_or_pointer = expr_1 ;
Rule 24    assignment -> array = expr_1 ;
Rule 25    assignment -> variable_or_pointer = & VARIABLE ;
Rule 26    assignment -> array = & VARIABLE ;
Rule 27    return_expr -> RETURN expr_1 ;
Rule 28    return_expr -> RETURN ;
Rule 29    expr_line -> expr_1 ;
Rule 30    printf_expr -> PRINTF ( STRING ) ;
Rule 31    printf_expr -> PRINTF ( digit ) ;
Rule 32    printf_expr -> PRINTF ( float ) ;
Rule 33    digit -> DIGIT_STRING , expr_1
Rule 34    float -> FLOAT_STRING , expr_1
Rule 35    variable_or_pointer -> * VARIABLE
Rule 36    variable_or_pointer -> VARIABLE
Rule 37    expr_1 -> expr_2 > expr_1
Rule 38    expr_1 -> expr_2 < expr_1
Rule 39    expr_1 -> expr_2
Rule 40    expr_2 -> expr_3 PLUS expr_2
Rule 41    expr_2 -> expr_3 - expr_2
Rule 42    expr_2 -> expr_3
Rule 43    expr_3 -> expr_4 * expr_3
Rule 44    expr_3 -> expr_4 / expr_3
Rule 45    expr_3 -> expr_4
Rule 46    expr_4 -> - expr_5
Rule 47    expr_4 -> expr_5
Rule 48    expr_5 -> variable_or_pointer INCR
Rule 49    expr_5 -> expr_6
Rule 50    expr_6 -> INTEGER
Rule 51    expr_6 -> FLOAT
Rule 52    expr_6 -> variable_or_pointer
Rule 53    expr_6 -> function_call
Rule 54    expr_6 -> array
Rule 55    expr_6 -> ( expr_1 )
Rule 56    if_clause -> IF ( expr_1 ) { body }
Rule 57    for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body }
Rule 58    function_call -> VARIABLE ( arguments_call )
Rule 59    function_call -> VARIABLE ( )
Rule 60    arguments_call -> expr_1
Rule 61    arguments_call -> expr_1 , arguments_call
Rule 62    array -> VARIABLE [ expr_1 ]
Rule 63    type_func -> INT_TYPE
Rule 64    type_func -> FLOAT_TYPE
Rule 65    type_func -> VOID_TYPE
Rule 66    type_var -> INT_TYPE
Rule 67    type_var -> FLOAT_TYPE
Rule 68    line -> error ;
Rule 69    function -> error VARIABLE ( arguments ) { body }
Rule 70    function -> type_func error ( arguments ) { body }
Rule 71    function -> type_func VARIABLE arguments ) { body }
Rule 72    function -> type_func VARIABLE ( error ) { body }
Rule 73    function -> type_func VARIABLE ( arguments { body }
Rule 74    function -> type_func VARIABLE ( arguments ) body }
Rule 75    function -> type_func VARIABLE ( arguments ) { error }
Rule 76    function -> type_func VARIABLE ( arguments ) { body
Rule 77    assignment -> error = expr_1 ;
Rule 78    assignment -> variable_or_pointer expr_1 ;
Rule 79    assignment -> array expr_1 ;
Rule 80    assignment -> variable_or_pointer = error ;
Rule 81    assignment -> array = error ;
Rule 82    assignment -> variable_or_pointer = expr_1
Rule 83    assignment -> array = expr_1
Rule 84    assignment -> error = & VARIABLE ;
Rule 85    assignment -> variable_or_pointer & VARIABLE ;
Rule 86    assignment -> array & VARIABLE ;
Rule 87    assignment -> variable_or_pointer = & error ;
Rule 88    assignment -> array = & error ;
Rule 89    assignment -> variable_or_pointer = & VARIABLE
Rule 90    assignment -> array = & VARIABLE
Rule 91    return_expr -> RETURN error ;
Rule 92    return_expr -> RETURN expr_1
Rule 93    return_expr -> RETURN
Rule 94    expr_line -> expr_1
Rule 95    expr_line -> error ;
Rule 96    printf_expr -> error ( STRING ) ;
Rule 97    printf_expr -> error ( digit ) ;
Rule 98    printf_expr -> error ( float ) ;
Rule 99    printf_expr -> PRINTF STRING ) ;
Rule 100   printf_expr -> PRINTF digit ) ;
Rule 101   printf_expr -> PRINTF float ) ;
Rule 102   printf_expr -> PRINTF ( error ) ;
Rule 103   printf_expr -> PRINTF ( STRING ;
Rule 104   printf_expr -> PRINTF ( digit ;
Rule 105   printf_expr -> PRINTF ( float ;
Rule 106   printf_expr -> PRINTF ( STRING )
Rule 107   printf_expr -> PRINTF ( digit )
Rule 108   printf_expr -> PRINTF ( float )
Rule 109   if_clause -> error ( expr_1 ) { body }
Rule 110   if_clause -> IF expr_1 ) { body }
Rule 111   if_clause -> IF ( error ) { body }
Rule 112   if_clause -> IF ( expr_1 { body }
Rule 113   if_clause -> IF ( expr_1 ) body }
Rule 114   if_clause -> IF ( expr_1 ) { error }
Rule 115   if_clause -> IF ( expr_1 ) { body
Rule 116   for_loop -> error ( assignment expr_1 ; expr_1 ) { body }
Rule 117   for_loop -> FOR assignment expr_1 ; expr_1 ) { body }
Rule 118   for_loop -> FOR ( error expr_1 ; expr_1 ) { body }
Rule 119   for_loop -> FOR ( assignment error ; expr_1 ) { body }
Rule 120   for_loop -> FOR ( assignment expr_1 expr_1 ) { body }
Rule 121   for_loop -> FOR ( assignment expr_1 ; error ) { body }
Rule 122   for_loop -> FOR ( assignment expr_1 ; expr_1 { body }
Rule 123   for_loop -> FOR ( assignment expr_1 ; expr_1 ) body }
Rule 124   for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error }
Rule 125   for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body
Rule 126   declaration -> error variable_list ;
Rule 127   declaration -> type_var error ;
Rule 128   declaration -> type_var variable_list
Rule 129   empty -> <empty>

Terminals, with rules where they appear

&                    : 25 26 84 85 86 87 88 89 90
(                    : 3 30 31 32 55 56 57 58 59 69 70 72 73 74 75 76 96 97 98 102 103 104 105 106 107 108 109 111 112 113 114 115 116 118 119 120 121 122 123 124 125
)                    : 3 30 31 32 55 56 57 58 59 69 70 71 72 74 75 76 96 97 98 99 100 101 102 106 107 108 109 110 111 113 114 115 116 117 118 119 120 121 123 124 125
*                    : 35 43
,                    : 6 21 22 33 34 61
-                    : 41 46
/                    : 44
;                    : 18 23 24 25 26 27 28 29 30 31 32 57 68 77 78 79 80 81 84 85 86 87 88 91 95 96 97 98 99 100 101 102 103 104 105 116 117 118 119 121 122 123 124 125 126 127
<                    : 38
=                    : 23 24 25 26 77 80 81 82 83 84 87 88 89 90
>                    : 37
DIGIT_STRING         : 33
FLOAT                : 51
FLOAT_STRING         : 34
FLOAT_TYPE           : 64 67
FOR                  : 57 117 118 119 120 121 122 123 124 125
IF                   : 56 110 111 112 113 114 115
INCR                 : 48
INTEGER              : 50
INT_TYPE             : 63 66
PLUS                 : 40
PRINTF               : 30 31 32 99 100 101 102 103 104 105 106 107 108
RETURN               : 27 28 91 92 93
STRING               : 30 96 99 103 106
VARIABLE             : 3 25 26 35 36 58 59 62 69 71 72 73 74 75 76 84 85 86 89 90
VOID_TYPE            : 7 65
[                    : 62
]                    : 62
error                : 68 69 70 72 75 77 80 81 84 87 88 91 95 96 97 98 102 109 111 114 116 118 119 121 124 126 127
{                    : 3 56 57 69 70 71 72 73 75 76 109 110 111 112 114 115 116 117 118 119 120 121 122 124 125
}                    : 3 56 57 69 70 71 72 73 74 75 109 110 111 112 113 114 116 117 118 119 120 121 122 123 124

Nonterminals, with rules where they appear

arguments            : 3 69 70 71 73 74 75 76
arguments_call       : 58 61
arguments_rec        : 4 6
array                : 20 22 24 26 54 79 81 83 86 88 90
assignment           : 12 57 116 117 119 120 121 122 123 124 125
body                 : 3 9 56 57 69 70 71 72 73 74 76 109 110 111 112 113 115 116 117 118 119 120 121 122 123 125
declaration          : 11
digit                : 31 97 100 104 107
empty                : 2 8 10
expr_1               : 23 24 27 29 33 34 37 38 55 56 57 57 60 61 62 77 78 79 82 83 92 94 109 110 112 113 114 115 116 116 117 117 118 118 119 120 120 121 122 122 123 123 124 124 125 125
expr_2               : 37 38 39 40 41
expr_3               : 40 41 42 43 44
expr_4               : 43 44 45
expr_5               : 46 47
expr_6               : 49
expr_line            : 15
float                : 32 98 101 105 108
for_loop             : 14
function             : 1
function_call        : 53
function_list        : 1 0
if_clause            : 13
line                 : 9
printf_expr          : 17
return_expr          : 16
type_func            : 3 70 71 72 73 74 75 76
type_var             : 5 6 18 127 128
variable_list        : 18 21 22 126 128
variable_or_pointer  : 5 6 19 21 23 25 48 52 78 80 82 85 87 89

Parsing method: LALR

state 0

    (0) S' -> . function_list
    (1) function_list -> . function function_list
    (2) function_list -> . empty
    (3) function -> . type_func VARIABLE ( arguments ) { body }
    (69) function -> . error VARIABLE ( arguments ) { body }
    (70) function -> . type_func error ( arguments ) { body }
    (71) function -> . type_func VARIABLE arguments ) { body }
    (72) function -> . type_func VARIABLE ( error ) { body }
    (73) function -> . type_func VARIABLE ( arguments { body }
    (74) function -> . type_func VARIABLE ( arguments ) body }
    (75) function -> . type_func VARIABLE ( arguments ) { error }
    (76) function -> . type_func VARIABLE ( arguments ) { body
    (129) empty -> .
    (63) type_func -> . INT_TYPE
    (64) type_func -> . FLOAT_TYPE
    (65) type_func -> . VOID_TYPE

    error           shift and go to state 5
    $end            reduce using rule 129 (empty -> .)
    INT_TYPE        shift and go to state 6
    FLOAT_TYPE      shift and go to state 7
    VOID_TYPE       shift and go to state 8

    function_list                  shift and go to state 1
    function                       shift and go to state 2
    empty                          shift and go to state 3
    type_func                      shift and go to state 4

state 1

    (0) S' -> function_list .



state 2

    (1) function_list -> function . function_list
    (1) function_list -> . function function_list
    (2) function_list -> . empty
    (3) function -> . type_func VARIABLE ( arguments ) { body }
    (69) function -> . error VARIABLE ( arguments ) { body }
    (70) function -> . type_func error ( arguments ) { body }
    (71) function -> . type_func VARIABLE arguments ) { body }
    (72) function -> . type_func VARIABLE ( error ) { body }
    (73) function -> . type_func VARIABLE ( arguments { body }
    (74) function -> . type_func VARIABLE ( arguments ) body }
    (75) function -> . type_func VARIABLE ( arguments ) { error }
    (76) function -> . type_func VARIABLE ( arguments ) { body
    (129) empty -> .
    (63) type_func -> . INT_TYPE
    (64) type_func -> . FLOAT_TYPE
    (65) type_func -> . VOID_TYPE

    error           shift and go to state 5
    $end            reduce using rule 129 (empty -> .)
    INT_TYPE        shift and go to state 6
    FLOAT_TYPE      shift and go to state 7
    VOID_TYPE       shift and go to state 8

    function                       shift and go to state 2
    function_list                  shift and go to state 9
    empty                          shift and go to state 3
    type_func                      shift and go to state 4

state 3

    (2) function_list -> empty .

    $end            reduce using rule 2 (function_list -> empty .)


state 4

    (3) function -> type_func . VARIABLE ( arguments ) { body }
    (70) function -> type_func . error ( arguments ) { body }
    (71) function -> type_func . VARIABLE arguments ) { body }
    (72) function -> type_func . VARIABLE ( error ) { body }
    (73) function -> type_func . VARIABLE ( arguments { body }
    (74) function -> type_func . VARIABLE ( arguments ) body }
    (75) function -> type_func . VARIABLE ( arguments ) { error }
    (76) function -> type_func . VARIABLE ( arguments ) { body

    VARIABLE        shift and go to state 10
    error           shift and go to state 11


state 5

    (69) function -> error . VARIABLE ( arguments ) { body }

    VARIABLE        shift and go to state 12


state 6

    (63) type_func -> INT_TYPE .

    VARIABLE        reduce using rule 63 (type_func -> INT_TYPE .)
    error           reduce using rule 63 (type_func -> INT_TYPE .)


state 7

    (64) type_func -> FLOAT_TYPE .

    VARIABLE        reduce using rule 64 (type_func -> FLOAT_TYPE .)
    error           reduce using rule 64 (type_func -> FLOAT_TYPE .)


state 8

    (65) type_func -> VOID_TYPE .

    VARIABLE        reduce using rule 65 (type_func -> VOID_TYPE .)
    error           reduce using rule 65 (type_func -> VOID_TYPE .)


state 9

    (1) function_list -> function function_list .

    $end            reduce using rule 1 (function_list -> function function_list .)


state 10

    (3) function -> type_func VARIABLE . ( arguments ) { body }
    (71) function -> type_func VARIABLE . arguments ) { body }
    (72) function -> type_func VARIABLE . ( error ) { body }
    (73) function -> type_func VARIABLE . ( arguments { body }
    (74) function -> type_func VARIABLE . ( arguments ) body }
    (75) function -> type_func VARIABLE . ( arguments ) { error }
    (76) function -> type_func VARIABLE . ( arguments ) { body
    (4) arguments -> . arguments_rec
    (7) arguments -> . VOID_TYPE
    (8) arguments -> . empty
    (5) arguments_rec -> . type_var variable_or_pointer
    (6) arguments_rec -> . type_var variable_or_pointer , arguments_rec
    (129) empty -> .
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE

    (               shift and go to state 13
    VOID_TYPE       shift and go to state 16
    )               reduce using rule 129 (empty -> .)
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20

    arguments                      shift and go to state 14
    arguments_rec                  shift and go to state 15
    empty                          shift and go to state 17
    type_var                       shift and go to state 18

state 11

    (70) function -> type_func error . ( arguments ) { body }

    (               shift and go to state 21


state 12

    (69) function -> error VARIABLE . ( arguments ) { body }

    (               shift and go to state 22


state 13

    (3) function -> type_func VARIABLE ( . arguments ) { body }
    (72) function -> type_func VARIABLE ( . error ) { body }
    (73) function -> type_func VARIABLE ( . arguments { body }
    (74) function -> type_func VARIABLE ( . arguments ) body }
    (75) function -> type_func VARIABLE ( . arguments ) { error }
    (76) function -> type_func VARIABLE ( . arguments ) { body
    (4) arguments -> . arguments_rec
    (7) arguments -> . VOID_TYPE
    (8) arguments -> . empty
    (5) arguments_rec -> . type_var variable_or_pointer
    (6) arguments_rec -> . type_var variable_or_pointer , arguments_rec
    (129) empty -> .
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE

    error           shift and go to state 24
    VOID_TYPE       shift and go to state 16
    )               reduce using rule 129 (empty -> .)
    {               reduce using rule 129 (empty -> .)
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20

    arguments                      shift and go to state 23
    arguments_rec                  shift and go to state 15
    empty                          shift and go to state 17
    type_var                       shift and go to state 18

state 14

    (71) function -> type_func VARIABLE arguments . ) { body }

    )               shift and go to state 25


state 15

    (4) arguments -> arguments_rec .

    )               reduce using rule 4 (arguments -> arguments_rec .)
    {               reduce using rule 4 (arguments -> arguments_rec .)


state 16

    (7) arguments -> VOID_TYPE .

    )               reduce using rule 7 (arguments -> VOID_TYPE .)
    {               reduce using rule 7 (arguments -> VOID_TYPE .)


state 17

    (8) arguments -> empty .

    )               reduce using rule 8 (arguments -> empty .)
    {               reduce using rule 8 (arguments -> empty .)


state 18

    (5) arguments_rec -> type_var . variable_or_pointer
    (6) arguments_rec -> type_var . variable_or_pointer , arguments_rec
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE

    *               shift and go to state 27
    VARIABLE        shift and go to state 28

    variable_or_pointer            shift and go to state 26

state 19

    (66) type_var -> INT_TYPE .

    *               reduce using rule 66 (type_var -> INT_TYPE .)
    VARIABLE        reduce using rule 66 (type_var -> INT_TYPE .)
    error           reduce using rule 66 (type_var -> INT_TYPE .)


state 20

    (67) type_var -> FLOAT_TYPE .

    *               reduce using rule 67 (type_var -> FLOAT_TYPE .)
    VARIABLE        reduce using rule 67 (type_var -> FLOAT_TYPE .)
    error           reduce using rule 67 (type_var -> FLOAT_TYPE .)


state 21

    (70) function -> type_func error ( . arguments ) { body }
    (4) arguments -> . arguments_rec
    (7) arguments -> . VOID_TYPE
    (8) arguments -> . empty
    (5) arguments_rec -> . type_var variable_or_pointer
    (6) arguments_rec -> . type_var variable_or_pointer , arguments_rec
    (129) empty -> .
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE

    VOID_TYPE       shift and go to state 16
    )               reduce using rule 129 (empty -> .)
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20

    arguments                      shift and go to state 29
    arguments_rec                  shift and go to state 15
    empty                          shift and go to state 17
    type_var                       shift and go to state 18

state 22

    (69) function -> error VARIABLE ( . arguments ) { body }
    (4) arguments -> . arguments_rec
    (7) arguments -> . VOID_TYPE
    (8) arguments -> . empty
    (5) arguments_rec -> . type_var variable_or_pointer
    (6) arguments_rec -> . type_var variable_or_pointer , arguments_rec
    (129) empty -> .
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE

    VOID_TYPE       shift and go to state 16
    )               reduce using rule 129 (empty -> .)
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20

    arguments                      shift and go to state 30
    arguments_rec                  shift and go to state 15
    empty                          shift and go to state 17
    type_var                       shift and go to state 18

state 23

    (3) function -> type_func VARIABLE ( arguments . ) { body }
    (73) function -> type_func VARIABLE ( arguments . { body }
    (74) function -> type_func VARIABLE ( arguments . ) body }
    (75) function -> type_func VARIABLE ( arguments . ) { error }
    (76) function -> type_func VARIABLE ( arguments . ) { body

    )               shift and go to state 31
    {               shift and go to state 32


state 24

    (72) function -> type_func VARIABLE ( error . ) { body }

    )               shift and go to state 33


state 25

    (71) function -> type_func VARIABLE arguments ) . { body }

    {               shift and go to state 34


state 26

    (5) arguments_rec -> type_var variable_or_pointer .
    (6) arguments_rec -> type_var variable_or_pointer . , arguments_rec

    )               reduce using rule 5 (arguments_rec -> type_var variable_or_pointer .)
    {               reduce using rule 5 (arguments_rec -> type_var variable_or_pointer .)
    ,               shift and go to state 35


state 27

    (35) variable_or_pointer -> * . VARIABLE

    VARIABLE        shift and go to state 36


state 28

    (36) variable_or_pointer -> VARIABLE .

    ,               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    )               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    {               reduce using rule 36 (variable_or_pointer -> VARIABLE .)


state 29

    (70) function -> type_func error ( arguments . ) { body }

    )               shift and go to state 37


state 30

    (69) function -> error VARIABLE ( arguments . ) { body }

    )               shift and go to state 38


state 31

    (3) function -> type_func VARIABLE ( arguments ) . { body }
    (74) function -> type_func VARIABLE ( arguments ) . body }
    (75) function -> type_func VARIABLE ( arguments ) . { error }
    (76) function -> type_func VARIABLE ( arguments ) . { body
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    {               shift and go to state 41
    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    body                           shift and go to state 42
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    expr_1                         shift and go to state 55
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 32

    (73) function -> type_func VARIABLE ( arguments { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    body                           shift and go to state 70
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    expr_1                         shift and go to state 55
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 33

    (72) function -> type_func VARIABLE ( error ) . { body }

    {               shift and go to state 71


state 34

    (71) function -> type_func VARIABLE arguments ) { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    body                           shift and go to state 72
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    expr_1                         shift and go to state 55
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 35

    (6) arguments_rec -> type_var variable_or_pointer , . arguments_rec
    (5) arguments_rec -> . type_var variable_or_pointer
    (6) arguments_rec -> . type_var variable_or_pointer , arguments_rec
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE

    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20

    type_var                       shift and go to state 18
    arguments_rec                  shift and go to state 73

state 36

    (35) variable_or_pointer -> * VARIABLE .

    ,               reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    )               reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    {               reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    =               reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    &               reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    INCR            reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    -               reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    *               reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    VARIABLE        reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    INTEGER         reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    FLOAT           reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    (               reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    /               reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    PLUS            reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    >               reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    <               reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    ;               reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    error           reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    IF              reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    FOR             reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    RETURN          reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    PRINTF          reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    INT_TYPE        reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    FLOAT_TYPE      reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    }               reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    VOID_TYPE       reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    $end            reduce using rule 35 (variable_or_pointer -> * VARIABLE .)
    ]               reduce using rule 35 (variable_or_pointer -> * VARIABLE .)


state 37

    (70) function -> type_func error ( arguments ) . { body }

    {               shift and go to state 74


state 38

    (69) function -> error VARIABLE ( arguments ) . { body }

    {               shift and go to state 75


state 39

    (36) variable_or_pointer -> VARIABLE .
    (62) array -> VARIABLE . [ expr_1 ]
    (58) function_call -> VARIABLE . ( arguments_call )
    (59) function_call -> VARIABLE . ( )

  ! shift/reduce conflict for ( resolved as shift
    =               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    &               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    INCR            reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    -               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    *               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    VARIABLE        reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    INTEGER         reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    FLOAT           reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    /               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    PLUS            reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    >               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    <               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    ;               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    error           reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    IF              reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    FOR             reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    RETURN          reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    PRINTF          reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    INT_TYPE        reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    FLOAT_TYPE      reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    }               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    VOID_TYPE       reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    $end            reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    )               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    [               shift and go to state 76
    (               shift and go to state 77

  ! (               [ reduce using rule 36 (variable_or_pointer -> VARIABLE .) ]


state 40

    (55) expr_6 -> ( . expr_1 )
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 78
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 41

    (3) function -> type_func VARIABLE ( arguments ) { . body }
    (75) function -> type_func VARIABLE ( arguments ) { . error }
    (76) function -> type_func VARIABLE ( arguments ) { . body
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
    error           shift and go to state 83
    }               reduce using rule 129 (empty -> .)
    VOID_TYPE       reduce using rule 129 (empty -> .)
    $end            reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

  ! error           [ reduce using rule 129 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 129 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 129 (empty -> .) ]

    body                           shift and go to state 82
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    expr_1                         shift and go to state 55
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 42

    (74) function -> type_func VARIABLE ( arguments ) body . }

    }               shift and go to state 84


state 43

    (68) line -> error . ;
    (126) declaration -> error . variable_list ;
    (77) assignment -> error . = expr_1 ;
    (84) assignment -> error . = & VARIABLE ;
    (109) if_clause -> error . ( expr_1 ) { body }
    (116) for_loop -> error . ( assignment expr_1 ; expr_1 ) { body }
    (95) expr_line -> error . ;
    (96) printf_expr -> error . ( STRING ) ;
    (97) printf_expr -> error . ( digit ) ;
    (98) printf_expr -> error . ( float ) ;
    (19) variable_list -> . variable_or_pointer
    (20) variable_list -> . array
    (21) variable_list -> . variable_or_pointer , variable_list
    (22) variable_list -> . array , variable_list
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]

    ;               shift and go to state 85
    =               shift and go to state 87
    (               shift and go to state 89
    *               shift and go to state 27
    VARIABLE        shift and go to state 88

    variable_list                  shift and go to state 86
    variable_or_pointer            shift and go to state 90
    array                          shift and go to state 91

state 44

    (9) body -> line . body
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    VOID_TYPE       reduce using rule 129 (empty -> .)
    $end            reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

  ! error           [ reduce using rule 129 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 129 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 129 (empty -> .) ]
  ! IF              [ reduce using rule 129 (empty -> .) ]
  ! FOR             [ reduce using rule 129 (empty -> .) ]
  ! RETURN          [ reduce using rule 129 (empty -> .) ]
  ! PRINTF          [ reduce using rule 129 (empty -> .) ]
  ! *               [ reduce using rule 129 (empty -> .) ]
  ! VARIABLE        [ reduce using rule 129 (empty -> .) ]
  ! -               [ reduce using rule 129 (empty -> .) ]
  ! INTEGER         [ reduce using rule 129 (empty -> .) ]
  ! FLOAT           [ reduce using rule 129 (empty -> .) ]
  ! (               [ reduce using rule 129 (empty -> .) ]

    line                           shift and go to state 44
    body                           shift and go to state 92
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    expr_1                         shift and go to state 55
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 45

    (10) body -> empty .

    }               reduce using rule 10 (body -> empty .)
    error           reduce using rule 10 (body -> empty .)
    INT_TYPE        reduce using rule 10 (body -> empty .)
    FLOAT_TYPE      reduce using rule 10 (body -> empty .)
    VOID_TYPE       reduce using rule 10 (body -> empty .)
    $end            reduce using rule 10 (body -> empty .)
    IF              reduce using rule 10 (body -> empty .)
    FOR             reduce using rule 10 (body -> empty .)
    RETURN          reduce using rule 10 (body -> empty .)
    PRINTF          reduce using rule 10 (body -> empty .)
    *               reduce using rule 10 (body -> empty .)
    VARIABLE        reduce using rule 10 (body -> empty .)
    -               reduce using rule 10 (body -> empty .)
    INTEGER         reduce using rule 10 (body -> empty .)
    FLOAT           reduce using rule 10 (body -> empty .)
    (               reduce using rule 10 (body -> empty .)


state 46

    (11) line -> declaration .

    error           reduce using rule 11 (line -> declaration .)
    IF              reduce using rule 11 (line -> declaration .)
    FOR             reduce using rule 11 (line -> declaration .)
    RETURN          reduce using rule 11 (line -> declaration .)
    PRINTF          reduce using rule 11 (line -> declaration .)
    INT_TYPE        reduce using rule 11 (line -> declaration .)
    FLOAT_TYPE      reduce using rule 11 (line -> declaration .)
    *               reduce using rule 11 (line -> declaration .)
    VARIABLE        reduce using rule 11 (line -> declaration .)
    -               reduce using rule 11 (line -> declaration .)
    INTEGER         reduce using rule 11 (line -> declaration .)
    FLOAT           reduce using rule 11 (line -> declaration .)
    (               reduce using rule 11 (line -> declaration .)
    }               reduce using rule 11 (line -> declaration .)
    VOID_TYPE       reduce using rule 11 (line -> declaration .)
    $end            reduce using rule 11 (line -> declaration .)


state 47

    (12) line -> assignment .

    error           reduce using rule 12 (line -> assignment .)
    IF              reduce using rule 12 (line -> assignment .)
    FOR             reduce using rule 12 (line -> assignment .)
    RETURN          reduce using rule 12 (line -> assignment .)
    PRINTF          reduce using rule 12 (line -> assignment .)
    INT_TYPE        reduce using rule 12 (line -> assignment .)
    FLOAT_TYPE      reduce using rule 12 (line -> assignment .)
    *               reduce using rule 12 (line -> assignment .)
    VARIABLE        reduce using rule 12 (line -> assignment .)
    -               reduce using rule 12 (line -> assignment .)
    INTEGER         reduce using rule 12 (line -> assignment .)
    FLOAT           reduce using rule 12 (line -> assignment .)
    (               reduce using rule 12 (line -> assignment .)
    }               reduce using rule 12 (line -> assignment .)
    VOID_TYPE       reduce using rule 12 (line -> assignment .)
    $end            reduce using rule 12 (line -> assignment .)


state 48

    (13) line -> if_clause .

    error           reduce using rule 13 (line -> if_clause .)
    IF              reduce using rule 13 (line -> if_clause .)
    FOR             reduce using rule 13 (line -> if_clause .)
    RETURN          reduce using rule 13 (line -> if_clause .)
    PRINTF          reduce using rule 13 (line -> if_clause .)
    INT_TYPE        reduce using rule 13 (line -> if_clause .)
    FLOAT_TYPE      reduce using rule 13 (line -> if_clause .)
    *               reduce using rule 13 (line -> if_clause .)
    VARIABLE        reduce using rule 13 (line -> if_clause .)
    -               reduce using rule 13 (line -> if_clause .)
    INTEGER         reduce using rule 13 (line -> if_clause .)
    FLOAT           reduce using rule 13 (line -> if_clause .)
    (               reduce using rule 13 (line -> if_clause .)
    }               reduce using rule 13 (line -> if_clause .)
    VOID_TYPE       reduce using rule 13 (line -> if_clause .)
    $end            reduce using rule 13 (line -> if_clause .)


state 49

    (14) line -> for_loop .

    error           reduce using rule 14 (line -> for_loop .)
    IF              reduce using rule 14 (line -> for_loop .)
    FOR             reduce using rule 14 (line -> for_loop .)
    RETURN          reduce using rule 14 (line -> for_loop .)
    PRINTF          reduce using rule 14 (line -> for_loop .)
    INT_TYPE        reduce using rule 14 (line -> for_loop .)
    FLOAT_TYPE      reduce using rule 14 (line -> for_loop .)
    *               reduce using rule 14 (line -> for_loop .)
    VARIABLE        reduce using rule 14 (line -> for_loop .)
    -               reduce using rule 14 (line -> for_loop .)
    INTEGER         reduce using rule 14 (line -> for_loop .)
    FLOAT           reduce using rule 14 (line -> for_loop .)
    (               reduce using rule 14 (line -> for_loop .)
    }               reduce using rule 14 (line -> for_loop .)
    VOID_TYPE       reduce using rule 14 (line -> for_loop .)
    $end            reduce using rule 14 (line -> for_loop .)


state 50

    (15) line -> expr_line .

    error           reduce using rule 15 (line -> expr_line .)
    IF              reduce using rule 15 (line -> expr_line .)
    FOR             reduce using rule 15 (line -> expr_line .)
    RETURN          reduce using rule 15 (line -> expr_line .)
    PRINTF          reduce using rule 15 (line -> expr_line .)
    INT_TYPE        reduce using rule 15 (line -> expr_line .)
    FLOAT_TYPE      reduce using rule 15 (line -> expr_line .)
    *               reduce using rule 15 (line -> expr_line .)
    VARIABLE        reduce using rule 15 (line -> expr_line .)
    -               reduce using rule 15 (line -> expr_line .)
    INTEGER         reduce using rule 15 (line -> expr_line .)
    FLOAT           reduce using rule 15 (line -> expr_line .)
    (               reduce using rule 15 (line -> expr_line .)
    }               reduce using rule 15 (line -> expr_line .)
    VOID_TYPE       reduce using rule 15 (line -> expr_line .)
    $end            reduce using rule 15 (line -> expr_line .)


state 51

    (16) line -> return_expr .

    error           reduce using rule 16 (line -> return_expr .)
    IF              reduce using rule 16 (line -> return_expr .)
    FOR             reduce using rule 16 (line -> return_expr .)
    RETURN          reduce using rule 16 (line -> return_expr .)
    PRINTF          reduce using rule 16 (line -> return_expr .)
    INT_TYPE        reduce using rule 16 (line -> return_expr .)
    FLOAT_TYPE      reduce using rule 16 (line -> return_expr .)
    *               reduce using rule 16 (line -> return_expr .)
    VARIABLE        reduce using rule 16 (line -> return_expr .)
    -               reduce using rule 16 (line -> return_expr .)
    INTEGER         reduce using rule 16 (line -> return_expr .)
    FLOAT           reduce using rule 16 (line -> return_expr .)
    (               reduce using rule 16 (line -> return_expr .)
    }               reduce using rule 16 (line -> return_expr .)
    VOID_TYPE       reduce using rule 16 (line -> return_expr .)
    $end            reduce using rule 16 (line -> return_expr .)


state 52

    (17) line -> printf_expr .

    error           reduce using rule 17 (line -> printf_expr .)
    IF              reduce using rule 17 (line -> printf_expr .)
    FOR             reduce using rule 17 (line -> printf_expr .)
    RETURN          reduce using rule 17 (line -> printf_expr .)
    PRINTF          reduce using rule 17 (line -> printf_expr .)
    INT_TYPE        reduce using rule 17 (line -> printf_expr .)
    FLOAT_TYPE      reduce using rule 17 (line -> printf_expr .)
    *               reduce using rule 17 (line -> printf_expr .)
    VARIABLE        reduce using rule 17 (line -> printf_expr .)
    -               reduce using rule 17 (line -> printf_expr .)
    INTEGER         reduce using rule 17 (line -> printf_expr .)
    FLOAT           reduce using rule 17 (line -> printf_expr .)
    (               reduce using rule 17 (line -> printf_expr .)
    }               reduce using rule 17 (line -> printf_expr .)
    VOID_TYPE       reduce using rule 17 (line -> printf_expr .)
    $end            reduce using rule 17 (line -> printf_expr .)


state 53

    (18) declaration -> type_var . variable_list ;
    (127) declaration -> type_var . error ;
    (128) declaration -> type_var . variable_list
    (19) variable_list -> . variable_or_pointer
    (20) variable_list -> . array
    (21) variable_list -> . variable_or_pointer , variable_list
    (22) variable_list -> . array , variable_list
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]

    error           shift and go to state 94
    *               shift and go to state 27
    VARIABLE        shift and go to state 88

    variable_list                  shift and go to state 93
    variable_or_pointer            shift and go to state 90
    array                          shift and go to state 91

state 54

    (23) assignment -> variable_or_pointer . = expr_1 ;
    (25) assignment -> variable_or_pointer . = & VARIABLE ;
    (78) assignment -> variable_or_pointer . expr_1 ;
    (80) assignment -> variable_or_pointer . = error ;
    (82) assignment -> variable_or_pointer . = expr_1
    (85) assignment -> variable_or_pointer . & VARIABLE ;
    (87) assignment -> variable_or_pointer . = & error ;
    (89) assignment -> variable_or_pointer . = & VARIABLE
    (48) expr_5 -> variable_or_pointer . INCR
    (52) expr_6 -> variable_or_pointer .
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    =               shift and go to state 95
    &               shift and go to state 97
    INCR            shift and go to state 98
    /               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    PLUS            reduce using rule 52 (expr_6 -> variable_or_pointer .)
    >               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    <               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    ;               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    error           reduce using rule 52 (expr_6 -> variable_or_pointer .)
    IF              reduce using rule 52 (expr_6 -> variable_or_pointer .)
    FOR             reduce using rule 52 (expr_6 -> variable_or_pointer .)
    RETURN          reduce using rule 52 (expr_6 -> variable_or_pointer .)
    PRINTF          reduce using rule 52 (expr_6 -> variable_or_pointer .)
    INT_TYPE        reduce using rule 52 (expr_6 -> variable_or_pointer .)
    FLOAT_TYPE      reduce using rule 52 (expr_6 -> variable_or_pointer .)
    }               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    VOID_TYPE       reduce using rule 52 (expr_6 -> variable_or_pointer .)
    $end            reduce using rule 52 (expr_6 -> variable_or_pointer .)
    )               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

  ! *               [ reduce using rule 52 (expr_6 -> variable_or_pointer .) ]
  ! -               [ reduce using rule 52 (expr_6 -> variable_or_pointer .) ]
  ! VARIABLE        [ reduce using rule 52 (expr_6 -> variable_or_pointer .) ]
  ! INTEGER         [ reduce using rule 52 (expr_6 -> variable_or_pointer .) ]
  ! FLOAT           [ reduce using rule 52 (expr_6 -> variable_or_pointer .) ]
  ! (               [ reduce using rule 52 (expr_6 -> variable_or_pointer .) ]

    variable_or_pointer            shift and go to state 79
    expr_1                         shift and go to state 96
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 55

    (29) expr_line -> expr_1 . ;
    (94) expr_line -> expr_1 .

    ;               shift and go to state 99
    error           reduce using rule 94 (expr_line -> expr_1 .)
    IF              reduce using rule 94 (expr_line -> expr_1 .)
    FOR             reduce using rule 94 (expr_line -> expr_1 .)
    RETURN          reduce using rule 94 (expr_line -> expr_1 .)
    PRINTF          reduce using rule 94 (expr_line -> expr_1 .)
    INT_TYPE        reduce using rule 94 (expr_line -> expr_1 .)
    FLOAT_TYPE      reduce using rule 94 (expr_line -> expr_1 .)
    *               reduce using rule 94 (expr_line -> expr_1 .)
    VARIABLE        reduce using rule 94 (expr_line -> expr_1 .)
    -               reduce using rule 94 (expr_line -> expr_1 .)
    INTEGER         reduce using rule 94 (expr_line -> expr_1 .)
    FLOAT           reduce using rule 94 (expr_line -> expr_1 .)
    (               reduce using rule 94 (expr_line -> expr_1 .)
    }               reduce using rule 94 (expr_line -> expr_1 .)
    VOID_TYPE       reduce using rule 94 (expr_line -> expr_1 .)
    $end            reduce using rule 94 (expr_line -> expr_1 .)


state 56

    (24) assignment -> array . = expr_1 ;
    (26) assignment -> array . = & VARIABLE ;
    (79) assignment -> array . expr_1 ;
    (81) assignment -> array . = error ;
    (83) assignment -> array . = expr_1
    (86) assignment -> array . & VARIABLE ;
    (88) assignment -> array . = & error ;
    (90) assignment -> array . = & VARIABLE
    (54) expr_6 -> array .
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    =               shift and go to state 100
    &               shift and go to state 102
    /               reduce using rule 54 (expr_6 -> array .)
    PLUS            reduce using rule 54 (expr_6 -> array .)
    >               reduce using rule 54 (expr_6 -> array .)
    <               reduce using rule 54 (expr_6 -> array .)
    ;               reduce using rule 54 (expr_6 -> array .)
    error           reduce using rule 54 (expr_6 -> array .)
    IF              reduce using rule 54 (expr_6 -> array .)
    FOR             reduce using rule 54 (expr_6 -> array .)
    RETURN          reduce using rule 54 (expr_6 -> array .)
    PRINTF          reduce using rule 54 (expr_6 -> array .)
    INT_TYPE        reduce using rule 54 (expr_6 -> array .)
    FLOAT_TYPE      reduce using rule 54 (expr_6 -> array .)
    }               reduce using rule 54 (expr_6 -> array .)
    VOID_TYPE       reduce using rule 54 (expr_6 -> array .)
    $end            reduce using rule 54 (expr_6 -> array .)
    )               reduce using rule 54 (expr_6 -> array .)
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

  ! *               [ reduce using rule 54 (expr_6 -> array .) ]
  ! -               [ reduce using rule 54 (expr_6 -> array .) ]
  ! VARIABLE        [ reduce using rule 54 (expr_6 -> array .) ]
  ! INTEGER         [ reduce using rule 54 (expr_6 -> array .) ]
  ! FLOAT           [ reduce using rule 54 (expr_6 -> array .) ]
  ! (               [ reduce using rule 54 (expr_6 -> array .) ]

    array                          shift and go to state 81
    expr_1                         shift and go to state 101
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 57

    (56) if_clause -> IF . ( expr_1 ) { body }
    (110) if_clause -> IF . expr_1 ) { body }
    (111) if_clause -> IF . ( error ) { body }
    (112) if_clause -> IF . ( expr_1 { body }
    (113) if_clause -> IF . ( expr_1 ) body }
    (114) if_clause -> IF . ( expr_1 ) { error }
    (115) if_clause -> IF . ( expr_1 ) { body
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    (               shift and go to state 103
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68

    expr_1                         shift and go to state 104
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 58

    (57) for_loop -> FOR . ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> FOR . assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> FOR . ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> FOR . ( assignment error ; expr_1 ) { body }
    (120) for_loop -> FOR . ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> FOR . ( assignment expr_1 ; error ) { body }
    (122) for_loop -> FOR . ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> FOR . ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> FOR . ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> FOR . ( assignment expr_1 ; expr_1 ) { body
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]

    (               shift and go to state 105
    error           shift and go to state 107
    *               shift and go to state 27
    VARIABLE        shift and go to state 88

    assignment                     shift and go to state 106
    variable_or_pointer            shift and go to state 108
    array                          shift and go to state 109

state 59

    (27) return_expr -> RETURN . expr_1 ;
    (28) return_expr -> RETURN . ;
    (91) return_expr -> RETURN . error ;
    (92) return_expr -> RETURN . expr_1
    (93) return_expr -> RETURN .
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    ;               shift and go to state 111
    error           shift and go to state 112
    IF              reduce using rule 93 (return_expr -> RETURN .)
    FOR             reduce using rule 93 (return_expr -> RETURN .)
    RETURN          reduce using rule 93 (return_expr -> RETURN .)
    PRINTF          reduce using rule 93 (return_expr -> RETURN .)
    INT_TYPE        reduce using rule 93 (return_expr -> RETURN .)
    FLOAT_TYPE      reduce using rule 93 (return_expr -> RETURN .)
    }               reduce using rule 93 (return_expr -> RETURN .)
    VOID_TYPE       reduce using rule 93 (return_expr -> RETURN .)
    $end            reduce using rule 93 (return_expr -> RETURN .)
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

  ! error           [ reduce using rule 93 (return_expr -> RETURN .) ]
  ! *               [ reduce using rule 93 (return_expr -> RETURN .) ]
  ! VARIABLE        [ reduce using rule 93 (return_expr -> RETURN .) ]
  ! -               [ reduce using rule 93 (return_expr -> RETURN .) ]
  ! INTEGER         [ reduce using rule 93 (return_expr -> RETURN .) ]
  ! FLOAT           [ reduce using rule 93 (return_expr -> RETURN .) ]
  ! (               [ reduce using rule 93 (return_expr -> RETURN .) ]

    expr_1                         shift and go to state 110
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 60

    (30) printf_expr -> PRINTF . ( STRING ) ;
    (31) printf_expr -> PRINTF . ( digit ) ;
    (32) printf_expr -> PRINTF . ( float ) ;
    (99) printf_expr -> PRINTF . STRING ) ;
    (100) printf_expr -> PRINTF . digit ) ;
    (101) printf_expr -> PRINTF . float ) ;
    (102) printf_expr -> PRINTF . ( error ) ;
    (103) printf_expr -> PRINTF . ( STRING ;
    (104) printf_expr -> PRINTF . ( digit ;
    (105) printf_expr -> PRINTF . ( float ;
    (106) printf_expr -> PRINTF . ( STRING )
    (107) printf_expr -> PRINTF . ( digit )
    (108) printf_expr -> PRINTF . ( float )
    (33) digit -> . DIGIT_STRING , expr_1
    (34) float -> . FLOAT_STRING , expr_1

    (               shift and go to state 113
    STRING          shift and go to state 114
    DIGIT_STRING    shift and go to state 117
    FLOAT_STRING    shift and go to state 118

    digit                          shift and go to state 115
    float                          shift and go to state 116

state 61

    (37) expr_1 -> expr_2 . > expr_1
    (38) expr_1 -> expr_2 . < expr_1
    (39) expr_1 -> expr_2 .

    >               shift and go to state 119
    <               shift and go to state 120
    ;               reduce using rule 39 (expr_1 -> expr_2 .)
    error           reduce using rule 39 (expr_1 -> expr_2 .)
    IF              reduce using rule 39 (expr_1 -> expr_2 .)
    FOR             reduce using rule 39 (expr_1 -> expr_2 .)
    RETURN          reduce using rule 39 (expr_1 -> expr_2 .)
    PRINTF          reduce using rule 39 (expr_1 -> expr_2 .)
    INT_TYPE        reduce using rule 39 (expr_1 -> expr_2 .)
    FLOAT_TYPE      reduce using rule 39 (expr_1 -> expr_2 .)
    *               reduce using rule 39 (expr_1 -> expr_2 .)
    VARIABLE        reduce using rule 39 (expr_1 -> expr_2 .)
    -               reduce using rule 39 (expr_1 -> expr_2 .)
    INTEGER         reduce using rule 39 (expr_1 -> expr_2 .)
    FLOAT           reduce using rule 39 (expr_1 -> expr_2 .)
    (               reduce using rule 39 (expr_1 -> expr_2 .)
    }               reduce using rule 39 (expr_1 -> expr_2 .)
    )               reduce using rule 39 (expr_1 -> expr_2 .)
    VOID_TYPE       reduce using rule 39 (expr_1 -> expr_2 .)
    $end            reduce using rule 39 (expr_1 -> expr_2 .)
    ]               reduce using rule 39 (expr_1 -> expr_2 .)
    ,               reduce using rule 39 (expr_1 -> expr_2 .)
    {               reduce using rule 39 (expr_1 -> expr_2 .)


state 62

    (40) expr_2 -> expr_3 . PLUS expr_2
    (41) expr_2 -> expr_3 . - expr_2
    (42) expr_2 -> expr_3 .

  ! shift/reduce conflict for - resolved as shift
    PLUS            shift and go to state 121
    -               shift and go to state 122
    >               reduce using rule 42 (expr_2 -> expr_3 .)
    <               reduce using rule 42 (expr_2 -> expr_3 .)
    ;               reduce using rule 42 (expr_2 -> expr_3 .)
    error           reduce using rule 42 (expr_2 -> expr_3 .)
    IF              reduce using rule 42 (expr_2 -> expr_3 .)
    FOR             reduce using rule 42 (expr_2 -> expr_3 .)
    RETURN          reduce using rule 42 (expr_2 -> expr_3 .)
    PRINTF          reduce using rule 42 (expr_2 -> expr_3 .)
    INT_TYPE        reduce using rule 42 (expr_2 -> expr_3 .)
    FLOAT_TYPE      reduce using rule 42 (expr_2 -> expr_3 .)
    *               reduce using rule 42 (expr_2 -> expr_3 .)
    VARIABLE        reduce using rule 42 (expr_2 -> expr_3 .)
    INTEGER         reduce using rule 42 (expr_2 -> expr_3 .)
    FLOAT           reduce using rule 42 (expr_2 -> expr_3 .)
    (               reduce using rule 42 (expr_2 -> expr_3 .)
    }               reduce using rule 42 (expr_2 -> expr_3 .)
    )               reduce using rule 42 (expr_2 -> expr_3 .)
    VOID_TYPE       reduce using rule 42 (expr_2 -> expr_3 .)
    $end            reduce using rule 42 (expr_2 -> expr_3 .)
    ]               reduce using rule 42 (expr_2 -> expr_3 .)
    ,               reduce using rule 42 (expr_2 -> expr_3 .)
    {               reduce using rule 42 (expr_2 -> expr_3 .)

  ! -               [ reduce using rule 42 (expr_2 -> expr_3 .) ]


state 63

    (46) expr_4 -> - . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_5                         shift and go to state 123
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 64

    (43) expr_3 -> expr_4 . * expr_3
    (44) expr_3 -> expr_4 . / expr_3
    (45) expr_3 -> expr_4 .

  ! shift/reduce conflict for * resolved as shift
    *               shift and go to state 124
    /               shift and go to state 125
    PLUS            reduce using rule 45 (expr_3 -> expr_4 .)
    -               reduce using rule 45 (expr_3 -> expr_4 .)
    >               reduce using rule 45 (expr_3 -> expr_4 .)
    <               reduce using rule 45 (expr_3 -> expr_4 .)
    ;               reduce using rule 45 (expr_3 -> expr_4 .)
    error           reduce using rule 45 (expr_3 -> expr_4 .)
    IF              reduce using rule 45 (expr_3 -> expr_4 .)
    FOR             reduce using rule 45 (expr_3 -> expr_4 .)
    RETURN          reduce using rule 45 (expr_3 -> expr_4 .)
    PRINTF          reduce using rule 45 (expr_3 -> expr_4 .)
    INT_TYPE        reduce using rule 45 (expr_3 -> expr_4 .)
    FLOAT_TYPE      reduce using rule 45 (expr_3 -> expr_4 .)
    VARIABLE        reduce using rule 45 (expr_3 -> expr_4 .)
    INTEGER         reduce using rule 45 (expr_3 -> expr_4 .)
    FLOAT           reduce using rule 45 (expr_3 -> expr_4 .)
    (               reduce using rule 45 (expr_3 -> expr_4 .)
    }               reduce using rule 45 (expr_3 -> expr_4 .)
    )               reduce using rule 45 (expr_3 -> expr_4 .)
    VOID_TYPE       reduce using rule 45 (expr_3 -> expr_4 .)
    $end            reduce using rule 45 (expr_3 -> expr_4 .)
    ]               reduce using rule 45 (expr_3 -> expr_4 .)
    ,               reduce using rule 45 (expr_3 -> expr_4 .)
    {               reduce using rule 45 (expr_3 -> expr_4 .)

  ! *               [ reduce using rule 45 (expr_3 -> expr_4 .) ]


state 65

    (47) expr_4 -> expr_5 .

    *               reduce using rule 47 (expr_4 -> expr_5 .)
    /               reduce using rule 47 (expr_4 -> expr_5 .)
    PLUS            reduce using rule 47 (expr_4 -> expr_5 .)
    -               reduce using rule 47 (expr_4 -> expr_5 .)
    >               reduce using rule 47 (expr_4 -> expr_5 .)
    <               reduce using rule 47 (expr_4 -> expr_5 .)
    ;               reduce using rule 47 (expr_4 -> expr_5 .)
    error           reduce using rule 47 (expr_4 -> expr_5 .)
    IF              reduce using rule 47 (expr_4 -> expr_5 .)
    FOR             reduce using rule 47 (expr_4 -> expr_5 .)
    RETURN          reduce using rule 47 (expr_4 -> expr_5 .)
    PRINTF          reduce using rule 47 (expr_4 -> expr_5 .)
    INT_TYPE        reduce using rule 47 (expr_4 -> expr_5 .)
    FLOAT_TYPE      reduce using rule 47 (expr_4 -> expr_5 .)
    VARIABLE        reduce using rule 47 (expr_4 -> expr_5 .)
    INTEGER         reduce using rule 47 (expr_4 -> expr_5 .)
    FLOAT           reduce using rule 47 (expr_4 -> expr_5 .)
    (               reduce using rule 47 (expr_4 -> expr_5 .)
    }               reduce using rule 47 (expr_4 -> expr_5 .)
    )               reduce using rule 47 (expr_4 -> expr_5 .)
    VOID_TYPE       reduce using rule 47 (expr_4 -> expr_5 .)
    $end            reduce using rule 47 (expr_4 -> expr_5 .)
    ]               reduce using rule 47 (expr_4 -> expr_5 .)
    ,               reduce using rule 47 (expr_4 -> expr_5 .)
    {               reduce using rule 47 (expr_4 -> expr_5 .)


state 66

    (49) expr_5 -> expr_6 .

    *               reduce using rule 49 (expr_5 -> expr_6 .)
    /               reduce using rule 49 (expr_5 -> expr_6 .)
    PLUS            reduce using rule 49 (expr_5 -> expr_6 .)
    -               reduce using rule 49 (expr_5 -> expr_6 .)
    >               reduce using rule 49 (expr_5 -> expr_6 .)
    <               reduce using rule 49 (expr_5 -> expr_6 .)
    ;               reduce using rule 49 (expr_5 -> expr_6 .)
    error           reduce using rule 49 (expr_5 -> expr_6 .)
    IF              reduce using rule 49 (expr_5 -> expr_6 .)
    FOR             reduce using rule 49 (expr_5 -> expr_6 .)
    RETURN          reduce using rule 49 (expr_5 -> expr_6 .)
    PRINTF          reduce using rule 49 (expr_5 -> expr_6 .)
    INT_TYPE        reduce using rule 49 (expr_5 -> expr_6 .)
    FLOAT_TYPE      reduce using rule 49 (expr_5 -> expr_6 .)
    VARIABLE        reduce using rule 49 (expr_5 -> expr_6 .)
    INTEGER         reduce using rule 49 (expr_5 -> expr_6 .)
    FLOAT           reduce using rule 49 (expr_5 -> expr_6 .)
    (               reduce using rule 49 (expr_5 -> expr_6 .)
    }               reduce using rule 49 (expr_5 -> expr_6 .)
    )               reduce using rule 49 (expr_5 -> expr_6 .)
    VOID_TYPE       reduce using rule 49 (expr_5 -> expr_6 .)
    $end            reduce using rule 49 (expr_5 -> expr_6 .)
    ]               reduce using rule 49 (expr_5 -> expr_6 .)
    ,               reduce using rule 49 (expr_5 -> expr_6 .)
    {               reduce using rule 49 (expr_5 -> expr_6 .)


state 67

    (50) expr_6 -> INTEGER .

    *               reduce using rule 50 (expr_6 -> INTEGER .)
    /               reduce using rule 50 (expr_6 -> INTEGER .)
    PLUS            reduce using rule 50 (expr_6 -> INTEGER .)
    -               reduce using rule 50 (expr_6 -> INTEGER .)
    >               reduce using rule 50 (expr_6 -> INTEGER .)
    <               reduce using rule 50 (expr_6 -> INTEGER .)
    ;               reduce using rule 50 (expr_6 -> INTEGER .)
    error           reduce using rule 50 (expr_6 -> INTEGER .)
    IF              reduce using rule 50 (expr_6 -> INTEGER .)
    FOR             reduce using rule 50 (expr_6 -> INTEGER .)
    RETURN          reduce using rule 50 (expr_6 -> INTEGER .)
    PRINTF          reduce using rule 50 (expr_6 -> INTEGER .)
    INT_TYPE        reduce using rule 50 (expr_6 -> INTEGER .)
    FLOAT_TYPE      reduce using rule 50 (expr_6 -> INTEGER .)
    VARIABLE        reduce using rule 50 (expr_6 -> INTEGER .)
    INTEGER         reduce using rule 50 (expr_6 -> INTEGER .)
    FLOAT           reduce using rule 50 (expr_6 -> INTEGER .)
    (               reduce using rule 50 (expr_6 -> INTEGER .)
    }               reduce using rule 50 (expr_6 -> INTEGER .)
    )               reduce using rule 50 (expr_6 -> INTEGER .)
    VOID_TYPE       reduce using rule 50 (expr_6 -> INTEGER .)
    $end            reduce using rule 50 (expr_6 -> INTEGER .)
    ]               reduce using rule 50 (expr_6 -> INTEGER .)
    ,               reduce using rule 50 (expr_6 -> INTEGER .)
    {               reduce using rule 50 (expr_6 -> INTEGER .)


state 68

    (51) expr_6 -> FLOAT .

    *               reduce using rule 51 (expr_6 -> FLOAT .)
    /               reduce using rule 51 (expr_6 -> FLOAT .)
    PLUS            reduce using rule 51 (expr_6 -> FLOAT .)
    -               reduce using rule 51 (expr_6 -> FLOAT .)
    >               reduce using rule 51 (expr_6 -> FLOAT .)
    <               reduce using rule 51 (expr_6 -> FLOAT .)
    ;               reduce using rule 51 (expr_6 -> FLOAT .)
    error           reduce using rule 51 (expr_6 -> FLOAT .)
    IF              reduce using rule 51 (expr_6 -> FLOAT .)
    FOR             reduce using rule 51 (expr_6 -> FLOAT .)
    RETURN          reduce using rule 51 (expr_6 -> FLOAT .)
    PRINTF          reduce using rule 51 (expr_6 -> FLOAT .)
    INT_TYPE        reduce using rule 51 (expr_6 -> FLOAT .)
    FLOAT_TYPE      reduce using rule 51 (expr_6 -> FLOAT .)
    VARIABLE        reduce using rule 51 (expr_6 -> FLOAT .)
    INTEGER         reduce using rule 51 (expr_6 -> FLOAT .)
    FLOAT           reduce using rule 51 (expr_6 -> FLOAT .)
    (               reduce using rule 51 (expr_6 -> FLOAT .)
    }               reduce using rule 51 (expr_6 -> FLOAT .)
    )               reduce using rule 51 (expr_6 -> FLOAT .)
    VOID_TYPE       reduce using rule 51 (expr_6 -> FLOAT .)
    $end            reduce using rule 51 (expr_6 -> FLOAT .)
    ]               reduce using rule 51 (expr_6 -> FLOAT .)
    ,               reduce using rule 51 (expr_6 -> FLOAT .)
    {               reduce using rule 51 (expr_6 -> FLOAT .)


state 69

    (53) expr_6 -> function_call .

    *               reduce using rule 53 (expr_6 -> function_call .)
    /               reduce using rule 53 (expr_6 -> function_call .)
    PLUS            reduce using rule 53 (expr_6 -> function_call .)
    -               reduce using rule 53 (expr_6 -> function_call .)
    >               reduce using rule 53 (expr_6 -> function_call .)
    <               reduce using rule 53 (expr_6 -> function_call .)
    ;               reduce using rule 53 (expr_6 -> function_call .)
    error           reduce using rule 53 (expr_6 -> function_call .)
    IF              reduce using rule 53 (expr_6 -> function_call .)
    FOR             reduce using rule 53 (expr_6 -> function_call .)
    RETURN          reduce using rule 53 (expr_6 -> function_call .)
    PRINTF          reduce using rule 53 (expr_6 -> function_call .)
    INT_TYPE        reduce using rule 53 (expr_6 -> function_call .)
    FLOAT_TYPE      reduce using rule 53 (expr_6 -> function_call .)
    VARIABLE        reduce using rule 53 (expr_6 -> function_call .)
    INTEGER         reduce using rule 53 (expr_6 -> function_call .)
    FLOAT           reduce using rule 53 (expr_6 -> function_call .)
    (               reduce using rule 53 (expr_6 -> function_call .)
    }               reduce using rule 53 (expr_6 -> function_call .)
    )               reduce using rule 53 (expr_6 -> function_call .)
    VOID_TYPE       reduce using rule 53 (expr_6 -> function_call .)
    $end            reduce using rule 53 (expr_6 -> function_call .)
    ]               reduce using rule 53 (expr_6 -> function_call .)
    ,               reduce using rule 53 (expr_6 -> function_call .)
    {               reduce using rule 53 (expr_6 -> function_call .)


state 70

    (73) function -> type_func VARIABLE ( arguments { body . }

    }               shift and go to state 126


state 71

    (72) function -> type_func VARIABLE ( error ) { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    body                           shift and go to state 127
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    expr_1                         shift and go to state 55
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 72

    (71) function -> type_func VARIABLE arguments ) { body . }

    }               shift and go to state 128


state 73

    (6) arguments_rec -> type_var variable_or_pointer , arguments_rec .

    )               reduce using rule 6 (arguments_rec -> type_var variable_or_pointer , arguments_rec .)
    {               reduce using rule 6 (arguments_rec -> type_var variable_or_pointer , arguments_rec .)


state 74

    (70) function -> type_func error ( arguments ) { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    body                           shift and go to state 129
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    expr_1                         shift and go to state 55
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 75

    (69) function -> error VARIABLE ( arguments ) { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    body                           shift and go to state 130
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    expr_1                         shift and go to state 55
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 76

    (62) array -> VARIABLE [ . expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 131
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 77

    (58) function_call -> VARIABLE ( . arguments_call )
    (59) function_call -> VARIABLE ( . )
    (60) arguments_call -> . expr_1
    (61) arguments_call -> . expr_1 , arguments_call
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    )               shift and go to state 133
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    arguments_call                 shift and go to state 132
    expr_1                         shift and go to state 134
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 78

    (55) expr_6 -> ( expr_1 . )

    )               shift and go to state 135


state 79

    (48) expr_5 -> variable_or_pointer . INCR
    (52) expr_6 -> variable_or_pointer .

    INCR            shift and go to state 98
    *               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    /               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    PLUS            reduce using rule 52 (expr_6 -> variable_or_pointer .)
    -               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    >               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    <               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    )               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    ;               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    error           reduce using rule 52 (expr_6 -> variable_or_pointer .)
    IF              reduce using rule 52 (expr_6 -> variable_or_pointer .)
    FOR             reduce using rule 52 (expr_6 -> variable_or_pointer .)
    RETURN          reduce using rule 52 (expr_6 -> variable_or_pointer .)
    PRINTF          reduce using rule 52 (expr_6 -> variable_or_pointer .)
    INT_TYPE        reduce using rule 52 (expr_6 -> variable_or_pointer .)
    FLOAT_TYPE      reduce using rule 52 (expr_6 -> variable_or_pointer .)
    VARIABLE        reduce using rule 52 (expr_6 -> variable_or_pointer .)
    INTEGER         reduce using rule 52 (expr_6 -> variable_or_pointer .)
    FLOAT           reduce using rule 52 (expr_6 -> variable_or_pointer .)
    (               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    }               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    VOID_TYPE       reduce using rule 52 (expr_6 -> variable_or_pointer .)
    $end            reduce using rule 52 (expr_6 -> variable_or_pointer .)
    ]               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    ,               reduce using rule 52 (expr_6 -> variable_or_pointer .)
    {               reduce using rule 52 (expr_6 -> variable_or_pointer .)


state 80

    (36) variable_or_pointer -> VARIABLE .
    (58) function_call -> VARIABLE . ( arguments_call )
    (59) function_call -> VARIABLE . ( )
    (62) array -> VARIABLE . [ expr_1 ]

  ! shift/reduce conflict for ( resolved as shift
    INCR            reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    *               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    /               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    PLUS            reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    -               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    >               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    <               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    )               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    ;               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    error           reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    IF              reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    FOR             reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    RETURN          reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    PRINTF          reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    INT_TYPE        reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    FLOAT_TYPE      reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    VARIABLE        reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    INTEGER         reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    FLOAT           reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    }               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    VOID_TYPE       reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    $end            reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    ]               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    ,               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    {               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    (               shift and go to state 77
    [               shift and go to state 76

  ! (               [ reduce using rule 36 (variable_or_pointer -> VARIABLE .) ]


state 81

    (54) expr_6 -> array .

    *               reduce using rule 54 (expr_6 -> array .)
    /               reduce using rule 54 (expr_6 -> array .)
    PLUS            reduce using rule 54 (expr_6 -> array .)
    -               reduce using rule 54 (expr_6 -> array .)
    >               reduce using rule 54 (expr_6 -> array .)
    <               reduce using rule 54 (expr_6 -> array .)
    )               reduce using rule 54 (expr_6 -> array .)
    ;               reduce using rule 54 (expr_6 -> array .)
    error           reduce using rule 54 (expr_6 -> array .)
    IF              reduce using rule 54 (expr_6 -> array .)
    FOR             reduce using rule 54 (expr_6 -> array .)
    RETURN          reduce using rule 54 (expr_6 -> array .)
    PRINTF          reduce using rule 54 (expr_6 -> array .)
    INT_TYPE        reduce using rule 54 (expr_6 -> array .)
    FLOAT_TYPE      reduce using rule 54 (expr_6 -> array .)
    VARIABLE        reduce using rule 54 (expr_6 -> array .)
    INTEGER         reduce using rule 54 (expr_6 -> array .)
    FLOAT           reduce using rule 54 (expr_6 -> array .)
    (               reduce using rule 54 (expr_6 -> array .)
    }               reduce using rule 54 (expr_6 -> array .)
    VOID_TYPE       reduce using rule 54 (expr_6 -> array .)
    $end            reduce using rule 54 (expr_6 -> array .)
    ]               reduce using rule 54 (expr_6 -> array .)
    ,               reduce using rule 54 (expr_6 -> array .)
    {               reduce using rule 54 (expr_6 -> array .)


state 82

    (3) function -> type_func VARIABLE ( arguments ) { body . }
    (76) function -> type_func VARIABLE ( arguments ) { body .

    }               shift and go to state 136
    error           reduce using rule 76 (function -> type_func VARIABLE ( arguments ) { body .)
    INT_TYPE        reduce using rule 76 (function -> type_func VARIABLE ( arguments ) { body .)
    FLOAT_TYPE      reduce using rule 76 (function -> type_func VARIABLE ( arguments ) { body .)
    VOID_TYPE       reduce using rule 76 (function -> type_func VARIABLE ( arguments ) { body .)
    $end            reduce using rule 76 (function -> type_func VARIABLE ( arguments ) { body .)


state 83

    (75) function -> type_func VARIABLE ( arguments ) { error . }
    (68) line -> error . ;
    (126) declaration -> error . variable_list ;
    (77) assignment -> error . = expr_1 ;
    (84) assignment -> error . = & VARIABLE ;
    (109) if_clause -> error . ( expr_1 ) { body }
    (116) for_loop -> error . ( assignment expr_1 ; expr_1 ) { body }
    (95) expr_line -> error . ;
    (96) printf_expr -> error . ( STRING ) ;
    (97) printf_expr -> error . ( digit ) ;
    (98) printf_expr -> error . ( float ) ;
    (19) variable_list -> . variable_or_pointer
    (20) variable_list -> . array
    (21) variable_list -> . variable_or_pointer , variable_list
    (22) variable_list -> . array , variable_list
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]

    }               shift and go to state 137
    ;               shift and go to state 85
    =               shift and go to state 87
    (               shift and go to state 89
    *               shift and go to state 27
    VARIABLE        shift and go to state 88

    variable_list                  shift and go to state 86
    variable_or_pointer            shift and go to state 90
    array                          shift and go to state 91

state 84

    (74) function -> type_func VARIABLE ( arguments ) body } .

    error           reduce using rule 74 (function -> type_func VARIABLE ( arguments ) body } .)
    INT_TYPE        reduce using rule 74 (function -> type_func VARIABLE ( arguments ) body } .)
    FLOAT_TYPE      reduce using rule 74 (function -> type_func VARIABLE ( arguments ) body } .)
    VOID_TYPE       reduce using rule 74 (function -> type_func VARIABLE ( arguments ) body } .)
    $end            reduce using rule 74 (function -> type_func VARIABLE ( arguments ) body } .)


state 85

    (68) line -> error ; .
    (95) expr_line -> error ; .

  ! reduce/reduce conflict for error resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for IF resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for FOR resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for RETURN resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for PRINTF resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for INT_TYPE resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for FLOAT_TYPE resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for * resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for - resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for INTEGER resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for FLOAT resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for ( resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for } resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for VOID_TYPE resolved using rule 68 (line -> error ; .)
  ! reduce/reduce conflict for $end resolved using rule 68 (line -> error ; .)
    error           reduce using rule 68 (line -> error ; .)
    IF              reduce using rule 68 (line -> error ; .)
    FOR             reduce using rule 68 (line -> error ; .)
    RETURN          reduce using rule 68 (line -> error ; .)
    PRINTF          reduce using rule 68 (line -> error ; .)
    INT_TYPE        reduce using rule 68 (line -> error ; .)
    FLOAT_TYPE      reduce using rule 68 (line -> error ; .)
    *               reduce using rule 68 (line -> error ; .)
    VARIABLE        reduce using rule 68 (line -> error ; .)
    -               reduce using rule 68 (line -> error ; .)
    INTEGER         reduce using rule 68 (line -> error ; .)
    FLOAT           reduce using rule 68 (line -> error ; .)
    (               reduce using rule 68 (line -> error ; .)
    }               reduce using rule 68 (line -> error ; .)
    VOID_TYPE       reduce using rule 68 (line -> error ; .)
    $end            reduce using rule 68 (line -> error ; .)

  ! error           [ reduce using rule 95 (expr_line -> error ; .) ]
  ! IF              [ reduce using rule 95 (expr_line -> error ; .) ]
  ! FOR             [ reduce using rule 95 (expr_line -> error ; .) ]
  ! RETURN          [ reduce using rule 95 (expr_line -> error ; .) ]
  ! PRINTF          [ reduce using rule 95 (expr_line -> error ; .) ]
  ! INT_TYPE        [ reduce using rule 95 (expr_line -> error ; .) ]
  ! FLOAT_TYPE      [ reduce using rule 95 (expr_line -> error ; .) ]
  ! *               [ reduce using rule 95 (expr_line -> error ; .) ]
  ! VARIABLE        [ reduce using rule 95 (expr_line -> error ; .) ]
  ! -               [ reduce using rule 95 (expr_line -> error ; .) ]
  ! INTEGER         [ reduce using rule 95 (expr_line -> error ; .) ]
  ! FLOAT           [ reduce using rule 95 (expr_line -> error ; .) ]
  ! (               [ reduce using rule 95 (expr_line -> error ; .) ]
  ! }               [ reduce using rule 95 (expr_line -> error ; .) ]
  ! VOID_TYPE       [ reduce using rule 95 (expr_line -> error ; .) ]
  ! $end            [ reduce using rule 95 (expr_line -> error ; .) ]


state 86

    (126) declaration -> error variable_list . ;

    ;               shift and go to state 138


state 87

    (77) assignment -> error = . expr_1 ;
    (84) assignment -> error = . & VARIABLE ;
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    &               shift and go to state 140
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 139
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 88

    (36) variable_or_pointer -> VARIABLE .
    (62) array -> VARIABLE . [ expr_1 ]

    ,               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    ;               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    error           reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    IF              reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    FOR             reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    RETURN          reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    PRINTF          reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    INT_TYPE        reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    FLOAT_TYPE      reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    *               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    VARIABLE        reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    -               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    INTEGER         reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    FLOAT           reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    (               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    }               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    VOID_TYPE       reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    $end            reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    =               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    &               reduce using rule 36 (variable_or_pointer -> VARIABLE .)
    [               shift and go to state 76


state 89

    (109) if_clause -> error ( . expr_1 ) { body }
    (116) for_loop -> error ( . assignment expr_1 ; expr_1 ) { body }
    (96) printf_expr -> error ( . STRING ) ;
    (97) printf_expr -> error ( . digit ) ;
    (98) printf_expr -> error ( . float ) ;
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (33) digit -> . DIGIT_STRING , expr_1
    (34) float -> . FLOAT_STRING , expr_1
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    STRING          shift and go to state 143
    error           shift and go to state 107
    DIGIT_STRING    shift and go to state 117
    FLOAT_STRING    shift and go to state 118
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 141
    assignment                     shift and go to state 142
    digit                          shift and go to state 144
    float                          shift and go to state 145
    expr_2                         shift and go to state 61
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 90

    (19) variable_list -> variable_or_pointer .
    (21) variable_list -> variable_or_pointer . , variable_list

    ;               reduce using rule 19 (variable_list -> variable_or_pointer .)
    error           reduce using rule 19 (variable_list -> variable_or_pointer .)
    IF              reduce using rule 19 (variable_list -> variable_or_pointer .)
    FOR             reduce using rule 19 (variable_list -> variable_or_pointer .)
    RETURN          reduce using rule 19 (variable_list -> variable_or_pointer .)
    PRINTF          reduce using rule 19 (variable_list -> variable_or_pointer .)
    INT_TYPE        reduce using rule 19 (variable_list -> variable_or_pointer .)
    FLOAT_TYPE      reduce using rule 19 (variable_list -> variable_or_pointer .)
    *               reduce using rule 19 (variable_list -> variable_or_pointer .)
    VARIABLE        reduce using rule 19 (variable_list -> variable_or_pointer .)
    -               reduce using rule 19 (variable_list -> variable_or_pointer .)
    INTEGER         reduce using rule 19 (variable_list -> variable_or_pointer .)
    FLOAT           reduce using rule 19 (variable_list -> variable_or_pointer .)
    (               reduce using rule 19 (variable_list -> variable_or_pointer .)
    }               reduce using rule 19 (variable_list -> variable_or_pointer .)
    VOID_TYPE       reduce using rule 19 (variable_list -> variable_or_pointer .)
    $end            reduce using rule 19 (variable_list -> variable_or_pointer .)
    ,               shift and go to state 146


state 91

    (20) variable_list -> array .
    (22) variable_list -> array . , variable_list

    ;               reduce using rule 20 (variable_list -> array .)
    error           reduce using rule 20 (variable_list -> array .)
    IF              reduce using rule 20 (variable_list -> array .)
    FOR             reduce using rule 20 (variable_list -> array .)
    RETURN          reduce using rule 20 (variable_list -> array .)
    PRINTF          reduce using rule 20 (variable_list -> array .)
    INT_TYPE        reduce using rule 20 (variable_list -> array .)
    FLOAT_TYPE      reduce using rule 20 (variable_list -> array .)
    *               reduce using rule 20 (variable_list -> array .)
    VARIABLE        reduce using rule 20 (variable_list -> array .)
    -               reduce using rule 20 (variable_list -> array .)
    INTEGER         reduce using rule 20 (variable_list -> array .)
    FLOAT           reduce using rule 20 (variable_list -> array .)
    (               reduce using rule 20 (variable_list -> array .)
    }               reduce using rule 20 (variable_list -> array .)
    VOID_TYPE       reduce using rule 20 (variable_list -> array .)
    $end            reduce using rule 20 (variable_list -> array .)
    ,               shift and go to state 147


state 92

    (9) body -> line body .

    }               reduce using rule 9 (body -> line body .)
    error           reduce using rule 9 (body -> line body .)
    INT_TYPE        reduce using rule 9 (body -> line body .)
    FLOAT_TYPE      reduce using rule 9 (body -> line body .)
    VOID_TYPE       reduce using rule 9 (body -> line body .)
    $end            reduce using rule 9 (body -> line body .)
    IF              reduce using rule 9 (body -> line body .)
    FOR             reduce using rule 9 (body -> line body .)
    RETURN          reduce using rule 9 (body -> line body .)
    PRINTF          reduce using rule 9 (body -> line body .)
    *               reduce using rule 9 (body -> line body .)
    VARIABLE        reduce using rule 9 (body -> line body .)
    -               reduce using rule 9 (body -> line body .)
    INTEGER         reduce using rule 9 (body -> line body .)
    FLOAT           reduce using rule 9 (body -> line body .)
    (               reduce using rule 9 (body -> line body .)


state 93

    (18) declaration -> type_var variable_list . ;
    (128) declaration -> type_var variable_list .

    ;               shift and go to state 148
    error           reduce using rule 128 (declaration -> type_var variable_list .)
    IF              reduce using rule 128 (declaration -> type_var variable_list .)
    FOR             reduce using rule 128 (declaration -> type_var variable_list .)
    RETURN          reduce using rule 128 (declaration -> type_var variable_list .)
    PRINTF          reduce using rule 128 (declaration -> type_var variable_list .)
    INT_TYPE        reduce using rule 128 (declaration -> type_var variable_list .)
    FLOAT_TYPE      reduce using rule 128 (declaration -> type_var variable_list .)
    *               reduce using rule 128 (declaration -> type_var variable_list .)
    VARIABLE        reduce using rule 128 (declaration -> type_var variable_list .)
    -               reduce using rule 128 (declaration -> type_var variable_list .)
    INTEGER         reduce using rule 128 (declaration -> type_var variable_list .)
    FLOAT           reduce using rule 128 (declaration -> type_var variable_list .)
    (               reduce using rule 128 (declaration -> type_var variable_list .)
    }               reduce using rule 128 (declaration -> type_var variable_list .)
    VOID_TYPE       reduce using rule 128 (declaration -> type_var variable_list .)
    $end            reduce using rule 128 (declaration -> type_var variable_list .)


state 94

    (127) declaration -> type_var error . ;

    ;               shift and go to state 149


state 95

    (23) assignment -> variable_or_pointer = . expr_1 ;
    (25) assignment -> variable_or_pointer = . & VARIABLE ;
    (80) assignment -> variable_or_pointer = . error ;
    (82) assignment -> variable_or_pointer = . expr_1
    (87) assignment -> variable_or_pointer = . & error ;
    (89) assignment -> variable_or_pointer = . & VARIABLE
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    &               shift and go to state 151
    error           shift and go to state 152
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    variable_or_pointer            shift and go to state 79
    expr_1                         shift and go to state 150
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 96

    (78) assignment -> variable_or_pointer expr_1 . ;

    ;               shift and go to state 153


state 97

    (85) assignment -> variable_or_pointer & . VARIABLE ;

    VARIABLE        shift and go to state 154


state 98

    (48) expr_5 -> variable_or_pointer INCR .

    *               reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    /               reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    PLUS            reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    -               reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    >               reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    <               reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    ;               reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    error           reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    IF              reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    FOR             reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    RETURN          reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    PRINTF          reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    INT_TYPE        reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    FLOAT_TYPE      reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    VARIABLE        reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    INTEGER         reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    FLOAT           reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    (               reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    }               reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    )               reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    VOID_TYPE       reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    $end            reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    ]               reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    ,               reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)
    {               reduce using rule 48 (expr_5 -> variable_or_pointer INCR .)


state 99

    (29) expr_line -> expr_1 ; .

    error           reduce using rule 29 (expr_line -> expr_1 ; .)
    IF              reduce using rule 29 (expr_line -> expr_1 ; .)
    FOR             reduce using rule 29 (expr_line -> expr_1 ; .)
    RETURN          reduce using rule 29 (expr_line -> expr_1 ; .)
    PRINTF          reduce using rule 29 (expr_line -> expr_1 ; .)
    INT_TYPE        reduce using rule 29 (expr_line -> expr_1 ; .)
    FLOAT_TYPE      reduce using rule 29 (expr_line -> expr_1 ; .)
    *               reduce using rule 29 (expr_line -> expr_1 ; .)
    VARIABLE        reduce using rule 29 (expr_line -> expr_1 ; .)
    -               reduce using rule 29 (expr_line -> expr_1 ; .)
    INTEGER         reduce using rule 29 (expr_line -> expr_1 ; .)
    FLOAT           reduce using rule 29 (expr_line -> expr_1 ; .)
    (               reduce using rule 29 (expr_line -> expr_1 ; .)
    }               reduce using rule 29 (expr_line -> expr_1 ; .)
    VOID_TYPE       reduce using rule 29 (expr_line -> expr_1 ; .)
    $end            reduce using rule 29 (expr_line -> expr_1 ; .)


state 100

    (24) assignment -> array = . expr_1 ;
    (26) assignment -> array = . & VARIABLE ;
    (81) assignment -> array = . error ;
    (83) assignment -> array = . expr_1
    (88) assignment -> array = . & error ;
    (90) assignment -> array = . & VARIABLE
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    &               shift and go to state 156
    error           shift and go to state 157
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    array                          shift and go to state 81
    expr_1                         shift and go to state 155
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 101

    (79) assignment -> array expr_1 . ;

    ;               shift and go to state 158


state 102

    (86) assignment -> array & . VARIABLE ;

    VARIABLE        shift and go to state 159


state 103

    (56) if_clause -> IF ( . expr_1 ) { body }
    (111) if_clause -> IF ( . error ) { body }
    (112) if_clause -> IF ( . expr_1 { body }
    (113) if_clause -> IF ( . expr_1 ) body }
    (114) if_clause -> IF ( . expr_1 ) { error }
    (115) if_clause -> IF ( . expr_1 ) { body
    (55) expr_6 -> ( . expr_1 )
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    error           shift and go to state 161
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 160
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 104

    (110) if_clause -> IF expr_1 . ) { body }

    )               shift and go to state 162


state 105

    (57) for_loop -> FOR ( . assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> FOR ( . error expr_1 ; expr_1 ) { body }
    (119) for_loop -> FOR ( . assignment error ; expr_1 ) { body }
    (120) for_loop -> FOR ( . assignment expr_1 expr_1 ) { body }
    (121) for_loop -> FOR ( . assignment expr_1 ; error ) { body }
    (122) for_loop -> FOR ( . assignment expr_1 ; expr_1 { body }
    (123) for_loop -> FOR ( . assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> FOR ( . assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> FOR ( . assignment expr_1 ; expr_1 ) { body
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]

    error           shift and go to state 164
    *               shift and go to state 27
    VARIABLE        shift and go to state 88

    assignment                     shift and go to state 163
    variable_or_pointer            shift and go to state 108
    array                          shift and go to state 109

state 106

    (117) for_loop -> FOR assignment . expr_1 ; expr_1 ) { body }
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 165
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 107

    (77) assignment -> error . = expr_1 ;
    (84) assignment -> error . = & VARIABLE ;

    =               shift and go to state 87


state 108

    (23) assignment -> variable_or_pointer . = expr_1 ;
    (25) assignment -> variable_or_pointer . = & VARIABLE ;
    (78) assignment -> variable_or_pointer . expr_1 ;
    (80) assignment -> variable_or_pointer . = error ;
    (82) assignment -> variable_or_pointer . = expr_1
    (85) assignment -> variable_or_pointer . & VARIABLE ;
    (87) assignment -> variable_or_pointer . = & error ;
    (89) assignment -> variable_or_pointer . = & VARIABLE
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    =               shift and go to state 95
    &               shift and go to state 97
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    variable_or_pointer            shift and go to state 79
    expr_1                         shift and go to state 96
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 109

    (24) assignment -> array . = expr_1 ;
    (26) assignment -> array . = & VARIABLE ;
    (79) assignment -> array . expr_1 ;
    (81) assignment -> array . = error ;
    (83) assignment -> array . = expr_1
    (86) assignment -> array . & VARIABLE ;
    (88) assignment -> array . = & error ;
    (90) assignment -> array . = & VARIABLE
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    =               shift and go to state 100
    &               shift and go to state 102
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    array                          shift and go to state 81
    expr_1                         shift and go to state 101
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 110

    (27) return_expr -> RETURN expr_1 . ;
    (92) return_expr -> RETURN expr_1 .

    ;               shift and go to state 166
    error           reduce using rule 92 (return_expr -> RETURN expr_1 .)
    IF              reduce using rule 92 (return_expr -> RETURN expr_1 .)
    FOR             reduce using rule 92 (return_expr -> RETURN expr_1 .)
    RETURN          reduce using rule 92 (return_expr -> RETURN expr_1 .)
    PRINTF          reduce using rule 92 (return_expr -> RETURN expr_1 .)
    INT_TYPE        reduce using rule 92 (return_expr -> RETURN expr_1 .)
    FLOAT_TYPE      reduce using rule 92 (return_expr -> RETURN expr_1 .)
    *               reduce using rule 92 (return_expr -> RETURN expr_1 .)
    VARIABLE        reduce using rule 92 (return_expr -> RETURN expr_1 .)
    -               reduce using rule 92 (return_expr -> RETURN expr_1 .)
    INTEGER         reduce using rule 92 (return_expr -> RETURN expr_1 .)
    FLOAT           reduce using rule 92 (return_expr -> RETURN expr_1 .)
    (               reduce using rule 92 (return_expr -> RETURN expr_1 .)
    }               reduce using rule 92 (return_expr -> RETURN expr_1 .)
    VOID_TYPE       reduce using rule 92 (return_expr -> RETURN expr_1 .)
    $end            reduce using rule 92 (return_expr -> RETURN expr_1 .)


state 111

    (28) return_expr -> RETURN ; .

    error           reduce using rule 28 (return_expr -> RETURN ; .)
    IF              reduce using rule 28 (return_expr -> RETURN ; .)
    FOR             reduce using rule 28 (return_expr -> RETURN ; .)
    RETURN          reduce using rule 28 (return_expr -> RETURN ; .)
    PRINTF          reduce using rule 28 (return_expr -> RETURN ; .)
    INT_TYPE        reduce using rule 28 (return_expr -> RETURN ; .)
    FLOAT_TYPE      reduce using rule 28 (return_expr -> RETURN ; .)
    *               reduce using rule 28 (return_expr -> RETURN ; .)
    VARIABLE        reduce using rule 28 (return_expr -> RETURN ; .)
    -               reduce using rule 28 (return_expr -> RETURN ; .)
    INTEGER         reduce using rule 28 (return_expr -> RETURN ; .)
    FLOAT           reduce using rule 28 (return_expr -> RETURN ; .)
    (               reduce using rule 28 (return_expr -> RETURN ; .)
    }               reduce using rule 28 (return_expr -> RETURN ; .)
    VOID_TYPE       reduce using rule 28 (return_expr -> RETURN ; .)
    $end            reduce using rule 28 (return_expr -> RETURN ; .)


state 112

    (91) return_expr -> RETURN error . ;

    ;               shift and go to state 167


state 113

    (30) printf_expr -> PRINTF ( . STRING ) ;
    (31) printf_expr -> PRINTF ( . digit ) ;
    (32) printf_expr -> PRINTF ( . float ) ;
    (102) printf_expr -> PRINTF ( . error ) ;
    (103) printf_expr -> PRINTF ( . STRING ;
    (104) printf_expr -> PRINTF ( . digit ;
    (105) printf_expr -> PRINTF ( . float ;
    (106) printf_expr -> PRINTF ( . STRING )
    (107) printf_expr -> PRINTF ( . digit )
    (108) printf_expr -> PRINTF ( . float )
    (33) digit -> . DIGIT_STRING , expr_1
    (34) float -> . FLOAT_STRING , expr_1

    STRING          shift and go to state 168
    error           shift and go to state 171
    DIGIT_STRING    shift and go to state 117
    FLOAT_STRING    shift and go to state 118

    digit                          shift and go to state 169
    float                          shift and go to state 170

state 114

    (99) printf_expr -> PRINTF STRING . ) ;

    )               shift and go to state 172


state 115

    (100) printf_expr -> PRINTF digit . ) ;

    )               shift and go to state 173


state 116

    (101) printf_expr -> PRINTF float . ) ;

    )               shift and go to state 174


state 117

    (33) digit -> DIGIT_STRING . , expr_1

    ,               shift and go to state 175


state 118

    (34) float -> FLOAT_STRING . , expr_1

    ,               shift and go to state 176


state 119

    (37) expr_1 -> expr_2 > . expr_1
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_2                         shift and go to state 61
    expr_1                         shift and go to state 177
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 120

    (38) expr_1 -> expr_2 < . expr_1
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_2                         shift and go to state 61
    expr_1                         shift and go to state 178
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 121

    (40) expr_2 -> expr_3 PLUS . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_3                         shift and go to state 62
    expr_2                         shift and go to state 179
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 122

    (41) expr_2 -> expr_3 - . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_3                         shift and go to state 62
    expr_2                         shift and go to state 180
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 123

    (46) expr_4 -> - expr_5 .

    *               reduce using rule 46 (expr_4 -> - expr_5 .)
    /               reduce using rule 46 (expr_4 -> - expr_5 .)
    PLUS            reduce using rule 46 (expr_4 -> - expr_5 .)
    -               reduce using rule 46 (expr_4 -> - expr_5 .)
    >               reduce using rule 46 (expr_4 -> - expr_5 .)
    <               reduce using rule 46 (expr_4 -> - expr_5 .)
    ;               reduce using rule 46 (expr_4 -> - expr_5 .)
    error           reduce using rule 46 (expr_4 -> - expr_5 .)
    IF              reduce using rule 46 (expr_4 -> - expr_5 .)
    FOR             reduce using rule 46 (expr_4 -> - expr_5 .)
    RETURN          reduce using rule 46 (expr_4 -> - expr_5 .)
    PRINTF          reduce using rule 46 (expr_4 -> - expr_5 .)
    INT_TYPE        reduce using rule 46 (expr_4 -> - expr_5 .)
    FLOAT_TYPE      reduce using rule 46 (expr_4 -> - expr_5 .)
    VARIABLE        reduce using rule 46 (expr_4 -> - expr_5 .)
    INTEGER         reduce using rule 46 (expr_4 -> - expr_5 .)
    FLOAT           reduce using rule 46 (expr_4 -> - expr_5 .)
    (               reduce using rule 46 (expr_4 -> - expr_5 .)
    }               reduce using rule 46 (expr_4 -> - expr_5 .)
    )               reduce using rule 46 (expr_4 -> - expr_5 .)
    VOID_TYPE       reduce using rule 46 (expr_4 -> - expr_5 .)
    $end            reduce using rule 46 (expr_4 -> - expr_5 .)
    ]               reduce using rule 46 (expr_4 -> - expr_5 .)
    ,               reduce using rule 46 (expr_4 -> - expr_5 .)
    {               reduce using rule 46 (expr_4 -> - expr_5 .)


state 124

    (43) expr_3 -> expr_4 * . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_4                         shift and go to state 64
    expr_3                         shift and go to state 181
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 125

    (44) expr_3 -> expr_4 / . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_4                         shift and go to state 64
    expr_3                         shift and go to state 182
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 126

    (73) function -> type_func VARIABLE ( arguments { body } .

    error           reduce using rule 73 (function -> type_func VARIABLE ( arguments { body } .)
    INT_TYPE        reduce using rule 73 (function -> type_func VARIABLE ( arguments { body } .)
    FLOAT_TYPE      reduce using rule 73 (function -> type_func VARIABLE ( arguments { body } .)
    VOID_TYPE       reduce using rule 73 (function -> type_func VARIABLE ( arguments { body } .)
    $end            reduce using rule 73 (function -> type_func VARIABLE ( arguments { body } .)


state 127

    (72) function -> type_func VARIABLE ( error ) { body . }

    }               shift and go to state 183


state 128

    (71) function -> type_func VARIABLE arguments ) { body } .

    error           reduce using rule 71 (function -> type_func VARIABLE arguments ) { body } .)
    INT_TYPE        reduce using rule 71 (function -> type_func VARIABLE arguments ) { body } .)
    FLOAT_TYPE      reduce using rule 71 (function -> type_func VARIABLE arguments ) { body } .)
    VOID_TYPE       reduce using rule 71 (function -> type_func VARIABLE arguments ) { body } .)
    $end            reduce using rule 71 (function -> type_func VARIABLE arguments ) { body } .)


state 129

    (70) function -> type_func error ( arguments ) { body . }

    }               shift and go to state 184


state 130

    (69) function -> error VARIABLE ( arguments ) { body . }

    }               shift and go to state 185


state 131

    (62) array -> VARIABLE [ expr_1 . ]

    ]               shift and go to state 186


state 132

    (58) function_call -> VARIABLE ( arguments_call . )

    )               shift and go to state 187


state 133

    (59) function_call -> VARIABLE ( ) .

    *               reduce using rule 59 (function_call -> VARIABLE ( ) .)
    /               reduce using rule 59 (function_call -> VARIABLE ( ) .)
    PLUS            reduce using rule 59 (function_call -> VARIABLE ( ) .)
    -               reduce using rule 59 (function_call -> VARIABLE ( ) .)
    >               reduce using rule 59 (function_call -> VARIABLE ( ) .)
    <               reduce using rule 59 (function_call -> VARIABLE ( ) .)
    ;               reduce using rule 59 (function_call -> VARIABLE ( ) .)
    error           reduce using rule 59 (function_call -> VARIABLE ( ) .)
    IF              reduce using rule 59 (function_call -> VARIABLE ( ) .)
    FOR             reduce using rule 59 (function_call -> VARIABLE ( ) .)
    RETURN          reduce using rule 59 (function_call -> VARIABLE ( ) .)
    PRINTF          reduce using rule 59 (function_call -> VARIABLE ( ) .)
    INT_TYPE        reduce using rule 59 (function_call -> VARIABLE ( ) .)
    FLOAT_TYPE      reduce using rule 59 (function_call -> VARIABLE ( ) .)
    VARIABLE        reduce using rule 59 (function_call -> VARIABLE ( ) .)
    INTEGER         reduce using rule 59 (function_call -> VARIABLE ( ) .)
    FLOAT           reduce using rule 59 (function_call -> VARIABLE ( ) .)
    (               reduce using rule 59 (function_call -> VARIABLE ( ) .)
    }               reduce using rule 59 (function_call -> VARIABLE ( ) .)
    )               reduce using rule 59 (function_call -> VARIABLE ( ) .)
    VOID_TYPE       reduce using rule 59 (function_call -> VARIABLE ( ) .)
    $end            reduce using rule 59 (function_call -> VARIABLE ( ) .)
    ]               reduce using rule 59 (function_call -> VARIABLE ( ) .)
    ,               reduce using rule 59 (function_call -> VARIABLE ( ) .)
    {               reduce using rule 59 (function_call -> VARIABLE ( ) .)


state 134

    (60) arguments_call -> expr_1 .
    (61) arguments_call -> expr_1 . , arguments_call

    )               reduce using rule 60 (arguments_call -> expr_1 .)
    ,               shift and go to state 188


state 135

    (55) expr_6 -> ( expr_1 ) .

    *               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    /               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    PLUS            reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    -               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    >               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    <               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    ;               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    error           reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    IF              reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    FOR             reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    RETURN          reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    PRINTF          reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    INT_TYPE        reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    FLOAT_TYPE      reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    VARIABLE        reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    INTEGER         reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    FLOAT           reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    (               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    }               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    )               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    VOID_TYPE       reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    $end            reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    ]               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    ,               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    {               reduce using rule 55 (expr_6 -> ( expr_1 ) .)


state 136

    (3) function -> type_func VARIABLE ( arguments ) { body } .

    error           reduce using rule 3 (function -> type_func VARIABLE ( arguments ) { body } .)
    INT_TYPE        reduce using rule 3 (function -> type_func VARIABLE ( arguments ) { body } .)
    FLOAT_TYPE      reduce using rule 3 (function -> type_func VARIABLE ( arguments ) { body } .)
    VOID_TYPE       reduce using rule 3 (function -> type_func VARIABLE ( arguments ) { body } .)
    $end            reduce using rule 3 (function -> type_func VARIABLE ( arguments ) { body } .)


state 137

    (75) function -> type_func VARIABLE ( arguments ) { error } .

    error           reduce using rule 75 (function -> type_func VARIABLE ( arguments ) { error } .)
    INT_TYPE        reduce using rule 75 (function -> type_func VARIABLE ( arguments ) { error } .)
    FLOAT_TYPE      reduce using rule 75 (function -> type_func VARIABLE ( arguments ) { error } .)
    VOID_TYPE       reduce using rule 75 (function -> type_func VARIABLE ( arguments ) { error } .)
    $end            reduce using rule 75 (function -> type_func VARIABLE ( arguments ) { error } .)


state 138

    (126) declaration -> error variable_list ; .

    error           reduce using rule 126 (declaration -> error variable_list ; .)
    IF              reduce using rule 126 (declaration -> error variable_list ; .)
    FOR             reduce using rule 126 (declaration -> error variable_list ; .)
    RETURN          reduce using rule 126 (declaration -> error variable_list ; .)
    PRINTF          reduce using rule 126 (declaration -> error variable_list ; .)
    INT_TYPE        reduce using rule 126 (declaration -> error variable_list ; .)
    FLOAT_TYPE      reduce using rule 126 (declaration -> error variable_list ; .)
    *               reduce using rule 126 (declaration -> error variable_list ; .)
    VARIABLE        reduce using rule 126 (declaration -> error variable_list ; .)
    -               reduce using rule 126 (declaration -> error variable_list ; .)
    INTEGER         reduce using rule 126 (declaration -> error variable_list ; .)
    FLOAT           reduce using rule 126 (declaration -> error variable_list ; .)
    (               reduce using rule 126 (declaration -> error variable_list ; .)
    }               reduce using rule 126 (declaration -> error variable_list ; .)
    VOID_TYPE       reduce using rule 126 (declaration -> error variable_list ; .)
    $end            reduce using rule 126 (declaration -> error variable_list ; .)


state 139

    (77) assignment -> error = expr_1 . ;

    ;               shift and go to state 189


state 140

    (84) assignment -> error = & . VARIABLE ;

    VARIABLE        shift and go to state 190


state 141

    (109) if_clause -> error ( expr_1 . ) { body }

    )               shift and go to state 191


state 142

    (116) for_loop -> error ( assignment . expr_1 ; expr_1 ) { body }
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 192
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 143

    (96) printf_expr -> error ( STRING . ) ;

    )               shift and go to state 193


state 144

    (97) printf_expr -> error ( digit . ) ;

    )               shift and go to state 194


state 145

    (98) printf_expr -> error ( float . ) ;

    )               shift and go to state 195


state 146

    (21) variable_list -> variable_or_pointer , . variable_list
    (19) variable_list -> . variable_or_pointer
    (20) variable_list -> . array
    (21) variable_list -> . variable_or_pointer , variable_list
    (22) variable_list -> . array , variable_list
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]

    *               shift and go to state 27
    VARIABLE        shift and go to state 88

    variable_or_pointer            shift and go to state 90
    variable_list                  shift and go to state 196
    array                          shift and go to state 91

state 147

    (22) variable_list -> array , . variable_list
    (19) variable_list -> . variable_or_pointer
    (20) variable_list -> . array
    (21) variable_list -> . variable_or_pointer , variable_list
    (22) variable_list -> . array , variable_list
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]

    *               shift and go to state 27
    VARIABLE        shift and go to state 88

    array                          shift and go to state 91
    variable_list                  shift and go to state 197
    variable_or_pointer            shift and go to state 90

state 148

    (18) declaration -> type_var variable_list ; .

    error           reduce using rule 18 (declaration -> type_var variable_list ; .)
    IF              reduce using rule 18 (declaration -> type_var variable_list ; .)
    FOR             reduce using rule 18 (declaration -> type_var variable_list ; .)
    RETURN          reduce using rule 18 (declaration -> type_var variable_list ; .)
    PRINTF          reduce using rule 18 (declaration -> type_var variable_list ; .)
    INT_TYPE        reduce using rule 18 (declaration -> type_var variable_list ; .)
    FLOAT_TYPE      reduce using rule 18 (declaration -> type_var variable_list ; .)
    *               reduce using rule 18 (declaration -> type_var variable_list ; .)
    VARIABLE        reduce using rule 18 (declaration -> type_var variable_list ; .)
    -               reduce using rule 18 (declaration -> type_var variable_list ; .)
    INTEGER         reduce using rule 18 (declaration -> type_var variable_list ; .)
    FLOAT           reduce using rule 18 (declaration -> type_var variable_list ; .)
    (               reduce using rule 18 (declaration -> type_var variable_list ; .)
    }               reduce using rule 18 (declaration -> type_var variable_list ; .)
    VOID_TYPE       reduce using rule 18 (declaration -> type_var variable_list ; .)
    $end            reduce using rule 18 (declaration -> type_var variable_list ; .)


state 149

    (127) declaration -> type_var error ; .

    error           reduce using rule 127 (declaration -> type_var error ; .)
    IF              reduce using rule 127 (declaration -> type_var error ; .)
    FOR             reduce using rule 127 (declaration -> type_var error ; .)
    RETURN          reduce using rule 127 (declaration -> type_var error ; .)
    PRINTF          reduce using rule 127 (declaration -> type_var error ; .)
    INT_TYPE        reduce using rule 127 (declaration -> type_var error ; .)
    FLOAT_TYPE      reduce using rule 127 (declaration -> type_var error ; .)
    *               reduce using rule 127 (declaration -> type_var error ; .)
    VARIABLE        reduce using rule 127 (declaration -> type_var error ; .)
    -               reduce using rule 127 (declaration -> type_var error ; .)
    INTEGER         reduce using rule 127 (declaration -> type_var error ; .)
    FLOAT           reduce using rule 127 (declaration -> type_var error ; .)
    (               reduce using rule 127 (declaration -> type_var error ; .)
    }               reduce using rule 127 (declaration -> type_var error ; .)
    VOID_TYPE       reduce using rule 127 (declaration -> type_var error ; .)
    $end            reduce using rule 127 (declaration -> type_var error ; .)


state 150

    (23) assignment -> variable_or_pointer = expr_1 . ;
    (82) assignment -> variable_or_pointer = expr_1 .

    ;               shift and go to state 198
    error           reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    IF              reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    FOR             reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    RETURN          reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    PRINTF          reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    INT_TYPE        reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    FLOAT_TYPE      reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    *               reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    VARIABLE        reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    -               reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    INTEGER         reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    FLOAT           reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    (               reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    }               reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    VOID_TYPE       reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)
    $end            reduce using rule 82 (assignment -> variable_or_pointer = expr_1 .)


state 151

    (25) assignment -> variable_or_pointer = & . VARIABLE ;
    (87) assignment -> variable_or_pointer = & . error ;
    (89) assignment -> variable_or_pointer = & . VARIABLE

    VARIABLE        shift and go to state 199
    error           shift and go to state 200


state 152

    (80) assignment -> variable_or_pointer = error . ;

    ;               shift and go to state 201


state 153

    (78) assignment -> variable_or_pointer expr_1 ; .

    error           reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    IF              reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    FOR             reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    RETURN          reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    PRINTF          reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    INT_TYPE        reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    FLOAT_TYPE      reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    *               reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    VARIABLE        reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    -               reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    INTEGER         reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    FLOAT           reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    (               reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    }               reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    VOID_TYPE       reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)
    $end            reduce using rule 78 (assignment -> variable_or_pointer expr_1 ; .)


state 154

    (85) assignment -> variable_or_pointer & VARIABLE . ;

    ;               shift and go to state 202


state 155

    (24) assignment -> array = expr_1 . ;
    (83) assignment -> array = expr_1 .

    ;               shift and go to state 203
    error           reduce using rule 83 (assignment -> array = expr_1 .)
    IF              reduce using rule 83 (assignment -> array = expr_1 .)
    FOR             reduce using rule 83 (assignment -> array = expr_1 .)
    RETURN          reduce using rule 83 (assignment -> array = expr_1 .)
    PRINTF          reduce using rule 83 (assignment -> array = expr_1 .)
    INT_TYPE        reduce using rule 83 (assignment -> array = expr_1 .)
    FLOAT_TYPE      reduce using rule 83 (assignment -> array = expr_1 .)
    *               reduce using rule 83 (assignment -> array = expr_1 .)
    VARIABLE        reduce using rule 83 (assignment -> array = expr_1 .)
    -               reduce using rule 83 (assignment -> array = expr_1 .)
    INTEGER         reduce using rule 83 (assignment -> array = expr_1 .)
    FLOAT           reduce using rule 83 (assignment -> array = expr_1 .)
    (               reduce using rule 83 (assignment -> array = expr_1 .)
    }               reduce using rule 83 (assignment -> array = expr_1 .)
    VOID_TYPE       reduce using rule 83 (assignment -> array = expr_1 .)
    $end            reduce using rule 83 (assignment -> array = expr_1 .)


state 156

    (26) assignment -> array = & . VARIABLE ;
    (88) assignment -> array = & . error ;
    (90) assignment -> array = & . VARIABLE

    VARIABLE        shift and go to state 204
    error           shift and go to state 205


state 157

    (81) assignment -> array = error . ;

    ;               shift and go to state 206


state 158

    (79) assignment -> array expr_1 ; .

    error           reduce using rule 79 (assignment -> array expr_1 ; .)
    IF              reduce using rule 79 (assignment -> array expr_1 ; .)
    FOR             reduce using rule 79 (assignment -> array expr_1 ; .)
    RETURN          reduce using rule 79 (assignment -> array expr_1 ; .)
    PRINTF          reduce using rule 79 (assignment -> array expr_1 ; .)
    INT_TYPE        reduce using rule 79 (assignment -> array expr_1 ; .)
    FLOAT_TYPE      reduce using rule 79 (assignment -> array expr_1 ; .)
    *               reduce using rule 79 (assignment -> array expr_1 ; .)
    VARIABLE        reduce using rule 79 (assignment -> array expr_1 ; .)
    -               reduce using rule 79 (assignment -> array expr_1 ; .)
    INTEGER         reduce using rule 79 (assignment -> array expr_1 ; .)
    FLOAT           reduce using rule 79 (assignment -> array expr_1 ; .)
    (               reduce using rule 79 (assignment -> array expr_1 ; .)
    }               reduce using rule 79 (assignment -> array expr_1 ; .)
    VOID_TYPE       reduce using rule 79 (assignment -> array expr_1 ; .)
    $end            reduce using rule 79 (assignment -> array expr_1 ; .)


state 159

    (86) assignment -> array & VARIABLE . ;

    ;               shift and go to state 207


state 160

    (56) if_clause -> IF ( expr_1 . ) { body }
    (112) if_clause -> IF ( expr_1 . { body }
    (113) if_clause -> IF ( expr_1 . ) body }
    (114) if_clause -> IF ( expr_1 . ) { error }
    (115) if_clause -> IF ( expr_1 . ) { body
    (55) expr_6 -> ( expr_1 . )

    )               shift and go to state 208
    {               shift and go to state 209


state 161

    (111) if_clause -> IF ( error . ) { body }

    )               shift and go to state 210


state 162

    (110) if_clause -> IF expr_1 ) . { body }

    {               shift and go to state 211


state 163

    (57) for_loop -> FOR ( assignment . expr_1 ; expr_1 ) { body }
    (119) for_loop -> FOR ( assignment . error ; expr_1 ) { body }
    (120) for_loop -> FOR ( assignment . expr_1 expr_1 ) { body }
    (121) for_loop -> FOR ( assignment . expr_1 ; error ) { body }
    (122) for_loop -> FOR ( assignment . expr_1 ; expr_1 { body }
    (123) for_loop -> FOR ( assignment . expr_1 ; expr_1 ) body }
    (124) for_loop -> FOR ( assignment . expr_1 ; expr_1 ) { error }
    (125) for_loop -> FOR ( assignment . expr_1 ; expr_1 ) { body
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    error           shift and go to state 213
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 212
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 164

    (118) for_loop -> FOR ( error . expr_1 ; expr_1 ) { body }
    (77) assignment -> error . = expr_1 ;
    (84) assignment -> error . = & VARIABLE ;
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    =               shift and go to state 87
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 214
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 165

    (117) for_loop -> FOR assignment expr_1 . ; expr_1 ) { body }

    ;               shift and go to state 215


state 166

    (27) return_expr -> RETURN expr_1 ; .

    error           reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    IF              reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    FOR             reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    RETURN          reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    PRINTF          reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    INT_TYPE        reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    FLOAT_TYPE      reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    *               reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    VARIABLE        reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    -               reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    INTEGER         reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    FLOAT           reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    (               reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    }               reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    VOID_TYPE       reduce using rule 27 (return_expr -> RETURN expr_1 ; .)
    $end            reduce using rule 27 (return_expr -> RETURN expr_1 ; .)


state 167

    (91) return_expr -> RETURN error ; .

    error           reduce using rule 91 (return_expr -> RETURN error ; .)
    IF              reduce using rule 91 (return_expr -> RETURN error ; .)
    FOR             reduce using rule 91 (return_expr -> RETURN error ; .)
    RETURN          reduce using rule 91 (return_expr -> RETURN error ; .)
    PRINTF          reduce using rule 91 (return_expr -> RETURN error ; .)
    INT_TYPE        reduce using rule 91 (return_expr -> RETURN error ; .)
    FLOAT_TYPE      reduce using rule 91 (return_expr -> RETURN error ; .)
    *               reduce using rule 91 (return_expr -> RETURN error ; .)
    VARIABLE        reduce using rule 91 (return_expr -> RETURN error ; .)
    -               reduce using rule 91 (return_expr -> RETURN error ; .)
    INTEGER         reduce using rule 91 (return_expr -> RETURN error ; .)
    FLOAT           reduce using rule 91 (return_expr -> RETURN error ; .)
    (               reduce using rule 91 (return_expr -> RETURN error ; .)
    }               reduce using rule 91 (return_expr -> RETURN error ; .)
    VOID_TYPE       reduce using rule 91 (return_expr -> RETURN error ; .)
    $end            reduce using rule 91 (return_expr -> RETURN error ; .)


state 168

    (30) printf_expr -> PRINTF ( STRING . ) ;
    (103) printf_expr -> PRINTF ( STRING . ;
    (106) printf_expr -> PRINTF ( STRING . )

    )               shift and go to state 216
    ;               shift and go to state 217


state 169

    (31) printf_expr -> PRINTF ( digit . ) ;
    (104) printf_expr -> PRINTF ( digit . ;
    (107) printf_expr -> PRINTF ( digit . )

    )               shift and go to state 218
    ;               shift and go to state 219


state 170

    (32) printf_expr -> PRINTF ( float . ) ;
    (105) printf_expr -> PRINTF ( float . ;
    (108) printf_expr -> PRINTF ( float . )

    )               shift and go to state 220
    ;               shift and go to state 221


state 171

    (102) printf_expr -> PRINTF ( error . ) ;

    )               shift and go to state 222


state 172

    (99) printf_expr -> PRINTF STRING ) . ;

    ;               shift and go to state 223


state 173

    (100) printf_expr -> PRINTF digit ) . ;

    ;               shift and go to state 224


state 174

    (101) printf_expr -> PRINTF float ) . ;

    ;               shift and go to state 225


state 175

    (33) digit -> DIGIT_STRING , . expr_1
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 226
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 176

    (34) float -> FLOAT_STRING , . expr_1
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 227
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 177

    (37) expr_1 -> expr_2 > expr_1 .

    ;               reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    error           reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    IF              reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    FOR             reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    RETURN          reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    PRINTF          reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    INT_TYPE        reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    FLOAT_TYPE      reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    *               reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    VARIABLE        reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    -               reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    INTEGER         reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    FLOAT           reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    (               reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    }               reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    )               reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    VOID_TYPE       reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    $end            reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    ]               reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    ,               reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)
    {               reduce using rule 37 (expr_1 -> expr_2 > expr_1 .)


state 178

    (38) expr_1 -> expr_2 < expr_1 .

    ;               reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    error           reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    IF              reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    FOR             reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    RETURN          reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    PRINTF          reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    INT_TYPE        reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    FLOAT_TYPE      reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    *               reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    VARIABLE        reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    -               reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    INTEGER         reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    FLOAT           reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    (               reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    }               reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    )               reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    VOID_TYPE       reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    $end            reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    ]               reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    ,               reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)
    {               reduce using rule 38 (expr_1 -> expr_2 < expr_1 .)


state 179

    (40) expr_2 -> expr_3 PLUS expr_2 .

    >               reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    <               reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    ;               reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    error           reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    IF              reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    FOR             reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    RETURN          reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    PRINTF          reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    INT_TYPE        reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    FLOAT_TYPE      reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    *               reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    VARIABLE        reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    -               reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    INTEGER         reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    FLOAT           reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    (               reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    }               reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    )               reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    VOID_TYPE       reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    $end            reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    ]               reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    ,               reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)
    {               reduce using rule 40 (expr_2 -> expr_3 PLUS expr_2 .)


state 180

    (41) expr_2 -> expr_3 - expr_2 .

    >               reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    <               reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    ;               reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    error           reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    IF              reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    FOR             reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    RETURN          reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    PRINTF          reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    INT_TYPE        reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    FLOAT_TYPE      reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    *               reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    VARIABLE        reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    -               reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    INTEGER         reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    FLOAT           reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    (               reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    }               reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    )               reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    VOID_TYPE       reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    $end            reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    ]               reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    ,               reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)
    {               reduce using rule 41 (expr_2 -> expr_3 - expr_2 .)


state 181

    (43) expr_3 -> expr_4 * expr_3 .

    PLUS            reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    -               reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    >               reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    <               reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    ;               reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    error           reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    IF              reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    FOR             reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    RETURN          reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    PRINTF          reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    INT_TYPE        reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    FLOAT_TYPE      reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    *               reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    VARIABLE        reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    INTEGER         reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    FLOAT           reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    (               reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    }               reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    )               reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    VOID_TYPE       reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    $end            reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    ]               reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    ,               reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)
    {               reduce using rule 43 (expr_3 -> expr_4 * expr_3 .)


state 182

    (44) expr_3 -> expr_4 / expr_3 .

    PLUS            reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    -               reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    >               reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    <               reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    ;               reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    error           reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    IF              reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    FOR             reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    RETURN          reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    PRINTF          reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    INT_TYPE        reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    FLOAT_TYPE      reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    *               reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    VARIABLE        reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    INTEGER         reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    FLOAT           reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    (               reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    }               reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    )               reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    VOID_TYPE       reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    $end            reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    ]               reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    ,               reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)
    {               reduce using rule 44 (expr_3 -> expr_4 / expr_3 .)


state 183

    (72) function -> type_func VARIABLE ( error ) { body } .

    error           reduce using rule 72 (function -> type_func VARIABLE ( error ) { body } .)
    INT_TYPE        reduce using rule 72 (function -> type_func VARIABLE ( error ) { body } .)
    FLOAT_TYPE      reduce using rule 72 (function -> type_func VARIABLE ( error ) { body } .)
    VOID_TYPE       reduce using rule 72 (function -> type_func VARIABLE ( error ) { body } .)
    $end            reduce using rule 72 (function -> type_func VARIABLE ( error ) { body } .)


state 184

    (70) function -> type_func error ( arguments ) { body } .

    error           reduce using rule 70 (function -> type_func error ( arguments ) { body } .)
    INT_TYPE        reduce using rule 70 (function -> type_func error ( arguments ) { body } .)
    FLOAT_TYPE      reduce using rule 70 (function -> type_func error ( arguments ) { body } .)
    VOID_TYPE       reduce using rule 70 (function -> type_func error ( arguments ) { body } .)
    $end            reduce using rule 70 (function -> type_func error ( arguments ) { body } .)


state 185

    (69) function -> error VARIABLE ( arguments ) { body } .

    error           reduce using rule 69 (function -> error VARIABLE ( arguments ) { body } .)
    INT_TYPE        reduce using rule 69 (function -> error VARIABLE ( arguments ) { body } .)
    FLOAT_TYPE      reduce using rule 69 (function -> error VARIABLE ( arguments ) { body } .)
    VOID_TYPE       reduce using rule 69 (function -> error VARIABLE ( arguments ) { body } .)
    $end            reduce using rule 69 (function -> error VARIABLE ( arguments ) { body } .)


state 186

    (62) array -> VARIABLE [ expr_1 ] .

    =               reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    &               reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    -               reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    *               reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    VARIABLE        reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    INTEGER         reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    FLOAT           reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    (               reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    /               reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    PLUS            reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    >               reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    <               reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    ;               reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    error           reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    IF              reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    FOR             reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    RETURN          reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    PRINTF          reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    INT_TYPE        reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    FLOAT_TYPE      reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    }               reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    )               reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    VOID_TYPE       reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    $end            reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    ,               reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    ]               reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)
    {               reduce using rule 62 (array -> VARIABLE [ expr_1 ] .)


state 187

    (58) function_call -> VARIABLE ( arguments_call ) .

    *               reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    /               reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    PLUS            reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    -               reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    >               reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    <               reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    ;               reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    error           reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    IF              reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    FOR             reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    RETURN          reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    PRINTF          reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    INT_TYPE        reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    FLOAT_TYPE      reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    VARIABLE        reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    INTEGER         reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    FLOAT           reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    (               reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    }               reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    )               reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    VOID_TYPE       reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    $end            reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    ]               reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    ,               reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)
    {               reduce using rule 58 (function_call -> VARIABLE ( arguments_call ) .)


state 188

    (61) arguments_call -> expr_1 , . arguments_call
    (60) arguments_call -> . expr_1
    (61) arguments_call -> . expr_1 , arguments_call
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 134
    arguments_call                 shift and go to state 228
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 189

    (77) assignment -> error = expr_1 ; .

    error           reduce using rule 77 (assignment -> error = expr_1 ; .)
    IF              reduce using rule 77 (assignment -> error = expr_1 ; .)
    FOR             reduce using rule 77 (assignment -> error = expr_1 ; .)
    RETURN          reduce using rule 77 (assignment -> error = expr_1 ; .)
    PRINTF          reduce using rule 77 (assignment -> error = expr_1 ; .)
    INT_TYPE        reduce using rule 77 (assignment -> error = expr_1 ; .)
    FLOAT_TYPE      reduce using rule 77 (assignment -> error = expr_1 ; .)
    *               reduce using rule 77 (assignment -> error = expr_1 ; .)
    VARIABLE        reduce using rule 77 (assignment -> error = expr_1 ; .)
    -               reduce using rule 77 (assignment -> error = expr_1 ; .)
    INTEGER         reduce using rule 77 (assignment -> error = expr_1 ; .)
    FLOAT           reduce using rule 77 (assignment -> error = expr_1 ; .)
    (               reduce using rule 77 (assignment -> error = expr_1 ; .)
    }               reduce using rule 77 (assignment -> error = expr_1 ; .)
    VOID_TYPE       reduce using rule 77 (assignment -> error = expr_1 ; .)
    $end            reduce using rule 77 (assignment -> error = expr_1 ; .)


state 190

    (84) assignment -> error = & VARIABLE . ;

    ;               shift and go to state 229


state 191

    (109) if_clause -> error ( expr_1 ) . { body }

    {               shift and go to state 230


state 192

    (116) for_loop -> error ( assignment expr_1 . ; expr_1 ) { body }

    ;               shift and go to state 231


state 193

    (96) printf_expr -> error ( STRING ) . ;

    ;               shift and go to state 232


state 194

    (97) printf_expr -> error ( digit ) . ;

    ;               shift and go to state 233


state 195

    (98) printf_expr -> error ( float ) . ;

    ;               shift and go to state 234


state 196

    (21) variable_list -> variable_or_pointer , variable_list .

    ;               reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    error           reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    IF              reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    FOR             reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    RETURN          reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    PRINTF          reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    INT_TYPE        reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    FLOAT_TYPE      reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    *               reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    VARIABLE        reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    -               reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    INTEGER         reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    FLOAT           reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    (               reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    }               reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    VOID_TYPE       reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)
    $end            reduce using rule 21 (variable_list -> variable_or_pointer , variable_list .)


state 197

    (22) variable_list -> array , variable_list .

    ;               reduce using rule 22 (variable_list -> array , variable_list .)
    error           reduce using rule 22 (variable_list -> array , variable_list .)
    IF              reduce using rule 22 (variable_list -> array , variable_list .)
    FOR             reduce using rule 22 (variable_list -> array , variable_list .)
    RETURN          reduce using rule 22 (variable_list -> array , variable_list .)
    PRINTF          reduce using rule 22 (variable_list -> array , variable_list .)
    INT_TYPE        reduce using rule 22 (variable_list -> array , variable_list .)
    FLOAT_TYPE      reduce using rule 22 (variable_list -> array , variable_list .)
    *               reduce using rule 22 (variable_list -> array , variable_list .)
    VARIABLE        reduce using rule 22 (variable_list -> array , variable_list .)
    -               reduce using rule 22 (variable_list -> array , variable_list .)
    INTEGER         reduce using rule 22 (variable_list -> array , variable_list .)
    FLOAT           reduce using rule 22 (variable_list -> array , variable_list .)
    (               reduce using rule 22 (variable_list -> array , variable_list .)
    }               reduce using rule 22 (variable_list -> array , variable_list .)
    VOID_TYPE       reduce using rule 22 (variable_list -> array , variable_list .)
    $end            reduce using rule 22 (variable_list -> array , variable_list .)


state 198

    (23) assignment -> variable_or_pointer = expr_1 ; .

    error           reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    IF              reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    FOR             reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    RETURN          reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    PRINTF          reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    INT_TYPE        reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    FLOAT_TYPE      reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    *               reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    VARIABLE        reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    -               reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    INTEGER         reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    FLOAT           reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    (               reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    }               reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    VOID_TYPE       reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)
    $end            reduce using rule 23 (assignment -> variable_or_pointer = expr_1 ; .)


state 199

    (25) assignment -> variable_or_pointer = & VARIABLE . ;
    (89) assignment -> variable_or_pointer = & VARIABLE .

    ;               shift and go to state 235
    error           reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    IF              reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    FOR             reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    RETURN          reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    PRINTF          reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    INT_TYPE        reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    FLOAT_TYPE      reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    *               reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    VARIABLE        reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    -               reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    INTEGER         reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    FLOAT           reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    (               reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    }               reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    VOID_TYPE       reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)
    $end            reduce using rule 89 (assignment -> variable_or_pointer = & VARIABLE .)


state 200

    (87) assignment -> variable_or_pointer = & error . ;

    ;               shift and go to state 236


state 201

    (80) assignment -> variable_or_pointer = error ; .

    error           reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    IF              reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    FOR             reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    RETURN          reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    PRINTF          reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    INT_TYPE        reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    FLOAT_TYPE      reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    *               reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    VARIABLE        reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    -               reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    INTEGER         reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    FLOAT           reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    (               reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    }               reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    VOID_TYPE       reduce using rule 80 (assignment -> variable_or_pointer = error ; .)
    $end            reduce using rule 80 (assignment -> variable_or_pointer = error ; .)


state 202

    (85) assignment -> variable_or_pointer & VARIABLE ; .

    error           reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    IF              reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    FOR             reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    RETURN          reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    PRINTF          reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    INT_TYPE        reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    FLOAT_TYPE      reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    *               reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    VARIABLE        reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    -               reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    INTEGER         reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    FLOAT           reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    (               reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    }               reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    VOID_TYPE       reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)
    $end            reduce using rule 85 (assignment -> variable_or_pointer & VARIABLE ; .)


state 203

    (24) assignment -> array = expr_1 ; .

    error           reduce using rule 24 (assignment -> array = expr_1 ; .)
    IF              reduce using rule 24 (assignment -> array = expr_1 ; .)
    FOR             reduce using rule 24 (assignment -> array = expr_1 ; .)
    RETURN          reduce using rule 24 (assignment -> array = expr_1 ; .)
    PRINTF          reduce using rule 24 (assignment -> array = expr_1 ; .)
    INT_TYPE        reduce using rule 24 (assignment -> array = expr_1 ; .)
    FLOAT_TYPE      reduce using rule 24 (assignment -> array = expr_1 ; .)
    *               reduce using rule 24 (assignment -> array = expr_1 ; .)
    VARIABLE        reduce using rule 24 (assignment -> array = expr_1 ; .)
    -               reduce using rule 24 (assignment -> array = expr_1 ; .)
    INTEGER         reduce using rule 24 (assignment -> array = expr_1 ; .)
    FLOAT           reduce using rule 24 (assignment -> array = expr_1 ; .)
    (               reduce using rule 24 (assignment -> array = expr_1 ; .)
    }               reduce using rule 24 (assignment -> array = expr_1 ; .)
    VOID_TYPE       reduce using rule 24 (assignment -> array = expr_1 ; .)
    $end            reduce using rule 24 (assignment -> array = expr_1 ; .)


state 204

    (26) assignment -> array = & VARIABLE . ;
    (90) assignment -> array = & VARIABLE .

    ;               shift and go to state 237
    error           reduce using rule 90 (assignment -> array = & VARIABLE .)
    IF              reduce using rule 90 (assignment -> array = & VARIABLE .)
    FOR             reduce using rule 90 (assignment -> array = & VARIABLE .)
    RETURN          reduce using rule 90 (assignment -> array = & VARIABLE .)
    PRINTF          reduce using rule 90 (assignment -> array = & VARIABLE .)
    INT_TYPE        reduce using rule 90 (assignment -> array = & VARIABLE .)
    FLOAT_TYPE      reduce using rule 90 (assignment -> array = & VARIABLE .)
    *               reduce using rule 90 (assignment -> array = & VARIABLE .)
    VARIABLE        reduce using rule 90 (assignment -> array = & VARIABLE .)
    -               reduce using rule 90 (assignment -> array = & VARIABLE .)
    INTEGER         reduce using rule 90 (assignment -> array = & VARIABLE .)
    FLOAT           reduce using rule 90 (assignment -> array = & VARIABLE .)
    (               reduce using rule 90 (assignment -> array = & VARIABLE .)
    }               reduce using rule 90 (assignment -> array = & VARIABLE .)
    VOID_TYPE       reduce using rule 90 (assignment -> array = & VARIABLE .)
    $end            reduce using rule 90 (assignment -> array = & VARIABLE .)


state 205

    (88) assignment -> array = & error . ;

    ;               shift and go to state 238


state 206

    (81) assignment -> array = error ; .

    error           reduce using rule 81 (assignment -> array = error ; .)
    IF              reduce using rule 81 (assignment -> array = error ; .)
    FOR             reduce using rule 81 (assignment -> array = error ; .)
    RETURN          reduce using rule 81 (assignment -> array = error ; .)
    PRINTF          reduce using rule 81 (assignment -> array = error ; .)
    INT_TYPE        reduce using rule 81 (assignment -> array = error ; .)
    FLOAT_TYPE      reduce using rule 81 (assignment -> array = error ; .)
    *               reduce using rule 81 (assignment -> array = error ; .)
    VARIABLE        reduce using rule 81 (assignment -> array = error ; .)
    -               reduce using rule 81 (assignment -> array = error ; .)
    INTEGER         reduce using rule 81 (assignment -> array = error ; .)
    FLOAT           reduce using rule 81 (assignment -> array = error ; .)
    (               reduce using rule 81 (assignment -> array = error ; .)
    }               reduce using rule 81 (assignment -> array = error ; .)
    VOID_TYPE       reduce using rule 81 (assignment -> array = error ; .)
    $end            reduce using rule 81 (assignment -> array = error ; .)


state 207

    (86) assignment -> array & VARIABLE ; .

    error           reduce using rule 86 (assignment -> array & VARIABLE ; .)
    IF              reduce using rule 86 (assignment -> array & VARIABLE ; .)
    FOR             reduce using rule 86 (assignment -> array & VARIABLE ; .)
    RETURN          reduce using rule 86 (assignment -> array & VARIABLE ; .)
    PRINTF          reduce using rule 86 (assignment -> array & VARIABLE ; .)
    INT_TYPE        reduce using rule 86 (assignment -> array & VARIABLE ; .)
    FLOAT_TYPE      reduce using rule 86 (assignment -> array & VARIABLE ; .)
    *               reduce using rule 86 (assignment -> array & VARIABLE ; .)
    VARIABLE        reduce using rule 86 (assignment -> array & VARIABLE ; .)
    -               reduce using rule 86 (assignment -> array & VARIABLE ; .)
    INTEGER         reduce using rule 86 (assignment -> array & VARIABLE ; .)
    FLOAT           reduce using rule 86 (assignment -> array & VARIABLE ; .)
    (               reduce using rule 86 (assignment -> array & VARIABLE ; .)
    }               reduce using rule 86 (assignment -> array & VARIABLE ; .)
    VOID_TYPE       reduce using rule 86 (assignment -> array & VARIABLE ; .)
    $end            reduce using rule 86 (assignment -> array & VARIABLE ; .)


state 208

    (56) if_clause -> IF ( expr_1 ) . { body }
    (113) if_clause -> IF ( expr_1 ) . body }
    (114) if_clause -> IF ( expr_1 ) . { error }
    (115) if_clause -> IF ( expr_1 ) . { body
    (55) expr_6 -> ( expr_1 ) .
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
    {               shift and go to state 239
    /               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    PLUS            reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    >               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    <               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    )               reduce using rule 55 (expr_6 -> ( expr_1 ) .)
    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

  ! *               [ reduce using rule 55 (expr_6 -> ( expr_1 ) .) ]
  ! -               [ reduce using rule 55 (expr_6 -> ( expr_1 ) .) ]

    expr_1                         shift and go to state 55
    body                           shift and go to state 240
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 209

    (112) if_clause -> IF ( expr_1 { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 55
    body                           shift and go to state 241
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 210

    (111) if_clause -> IF ( error ) . { body }

    {               shift and go to state 242


state 211

    (110) if_clause -> IF expr_1 ) { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 55
    body                           shift and go to state 243
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 212

    (57) for_loop -> FOR ( assignment expr_1 . ; expr_1 ) { body }
    (120) for_loop -> FOR ( assignment expr_1 . expr_1 ) { body }
    (121) for_loop -> FOR ( assignment expr_1 . ; error ) { body }
    (122) for_loop -> FOR ( assignment expr_1 . ; expr_1 { body }
    (123) for_loop -> FOR ( assignment expr_1 . ; expr_1 ) body }
    (124) for_loop -> FOR ( assignment expr_1 . ; expr_1 ) { error }
    (125) for_loop -> FOR ( assignment expr_1 . ; expr_1 ) { body
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    ;               shift and go to state 245
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 244
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 213

    (119) for_loop -> FOR ( assignment error . ; expr_1 ) { body }

    ;               shift and go to state 246


state 214

    (118) for_loop -> FOR ( error expr_1 . ; expr_1 ) { body }

    ;               shift and go to state 247


state 215

    (117) for_loop -> FOR assignment expr_1 ; . expr_1 ) { body }
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 248
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 216

    (30) printf_expr -> PRINTF ( STRING ) . ;
    (106) printf_expr -> PRINTF ( STRING ) .

    ;               shift and go to state 249
    error           reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    IF              reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    FOR             reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    RETURN          reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    PRINTF          reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    INT_TYPE        reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    FLOAT_TYPE      reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    *               reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    VARIABLE        reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    -               reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    INTEGER         reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    FLOAT           reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    (               reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    }               reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    VOID_TYPE       reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)
    $end            reduce using rule 106 (printf_expr -> PRINTF ( STRING ) .)


state 217

    (103) printf_expr -> PRINTF ( STRING ; .

    error           reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    IF              reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    FOR             reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    RETURN          reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    PRINTF          reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    INT_TYPE        reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    FLOAT_TYPE      reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    *               reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    VARIABLE        reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    -               reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    INTEGER         reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    FLOAT           reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    (               reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    }               reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    VOID_TYPE       reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)
    $end            reduce using rule 103 (printf_expr -> PRINTF ( STRING ; .)


state 218

    (31) printf_expr -> PRINTF ( digit ) . ;
    (107) printf_expr -> PRINTF ( digit ) .

    ;               shift and go to state 250
    error           reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    IF              reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    FOR             reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    RETURN          reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    PRINTF          reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    INT_TYPE        reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    FLOAT_TYPE      reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    *               reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    VARIABLE        reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    -               reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    INTEGER         reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    FLOAT           reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    (               reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    }               reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    VOID_TYPE       reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)
    $end            reduce using rule 107 (printf_expr -> PRINTF ( digit ) .)


state 219

    (104) printf_expr -> PRINTF ( digit ; .

    error           reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    IF              reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    FOR             reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    RETURN          reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    PRINTF          reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    INT_TYPE        reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    FLOAT_TYPE      reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    *               reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    VARIABLE        reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    -               reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    INTEGER         reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    FLOAT           reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    (               reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    }               reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    VOID_TYPE       reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)
    $end            reduce using rule 104 (printf_expr -> PRINTF ( digit ; .)


state 220

    (32) printf_expr -> PRINTF ( float ) . ;
    (108) printf_expr -> PRINTF ( float ) .

    ;               shift and go to state 251
    error           reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    IF              reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    FOR             reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    RETURN          reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    PRINTF          reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    INT_TYPE        reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    FLOAT_TYPE      reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    *               reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    VARIABLE        reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    -               reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    INTEGER         reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    FLOAT           reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    (               reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    }               reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    VOID_TYPE       reduce using rule 108 (printf_expr -> PRINTF ( float ) .)
    $end            reduce using rule 108 (printf_expr -> PRINTF ( float ) .)


state 221

    (105) printf_expr -> PRINTF ( float ; .

    error           reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    IF              reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    FOR             reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    RETURN          reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    PRINTF          reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    INT_TYPE        reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    FLOAT_TYPE      reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    *               reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    VARIABLE        reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    -               reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    INTEGER         reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    FLOAT           reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    (               reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    }               reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    VOID_TYPE       reduce using rule 105 (printf_expr -> PRINTF ( float ; .)
    $end            reduce using rule 105 (printf_expr -> PRINTF ( float ; .)


state 222

    (102) printf_expr -> PRINTF ( error ) . ;

    ;               shift and go to state 252


state 223

    (99) printf_expr -> PRINTF STRING ) ; .

    error           reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    IF              reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    FOR             reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    RETURN          reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    PRINTF          reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    INT_TYPE        reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    FLOAT_TYPE      reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    *               reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    VARIABLE        reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    -               reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    INTEGER         reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    FLOAT           reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    (               reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    }               reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    VOID_TYPE       reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)
    $end            reduce using rule 99 (printf_expr -> PRINTF STRING ) ; .)


state 224

    (100) printf_expr -> PRINTF digit ) ; .

    error           reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    IF              reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    FOR             reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    RETURN          reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    PRINTF          reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    INT_TYPE        reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    FLOAT_TYPE      reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    *               reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    VARIABLE        reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    -               reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    INTEGER         reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    FLOAT           reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    (               reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    }               reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    VOID_TYPE       reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)
    $end            reduce using rule 100 (printf_expr -> PRINTF digit ) ; .)


state 225

    (101) printf_expr -> PRINTF float ) ; .

    error           reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    IF              reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    FOR             reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    RETURN          reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    PRINTF          reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    INT_TYPE        reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    FLOAT_TYPE      reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    *               reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    VARIABLE        reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    -               reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    INTEGER         reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    FLOAT           reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    (               reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    }               reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    VOID_TYPE       reduce using rule 101 (printf_expr -> PRINTF float ) ; .)
    $end            reduce using rule 101 (printf_expr -> PRINTF float ) ; .)


state 226

    (33) digit -> DIGIT_STRING , expr_1 .

    )               reduce using rule 33 (digit -> DIGIT_STRING , expr_1 .)
    ;               reduce using rule 33 (digit -> DIGIT_STRING , expr_1 .)


state 227

    (34) float -> FLOAT_STRING , expr_1 .

    )               reduce using rule 34 (float -> FLOAT_STRING , expr_1 .)
    ;               reduce using rule 34 (float -> FLOAT_STRING , expr_1 .)


state 228

    (61) arguments_call -> expr_1 , arguments_call .

    )               reduce using rule 61 (arguments_call -> expr_1 , arguments_call .)


state 229

    (84) assignment -> error = & VARIABLE ; .

    error           reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    IF              reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    FOR             reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    RETURN          reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    PRINTF          reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    INT_TYPE        reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    FLOAT_TYPE      reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    *               reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    VARIABLE        reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    -               reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    INTEGER         reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    FLOAT           reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    (               reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    }               reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    VOID_TYPE       reduce using rule 84 (assignment -> error = & VARIABLE ; .)
    $end            reduce using rule 84 (assignment -> error = & VARIABLE ; .)


state 230

    (109) if_clause -> error ( expr_1 ) { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 55
    body                           shift and go to state 253
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 231

    (116) for_loop -> error ( assignment expr_1 ; . expr_1 ) { body }
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 254
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 232

    (96) printf_expr -> error ( STRING ) ; .

    error           reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    IF              reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    FOR             reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    RETURN          reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    PRINTF          reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    INT_TYPE        reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    FLOAT_TYPE      reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    *               reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    VARIABLE        reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    -               reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    INTEGER         reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    FLOAT           reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    (               reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    }               reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    VOID_TYPE       reduce using rule 96 (printf_expr -> error ( STRING ) ; .)
    $end            reduce using rule 96 (printf_expr -> error ( STRING ) ; .)


state 233

    (97) printf_expr -> error ( digit ) ; .

    error           reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    IF              reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    FOR             reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    RETURN          reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    PRINTF          reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    INT_TYPE        reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    FLOAT_TYPE      reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    *               reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    VARIABLE        reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    -               reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    INTEGER         reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    FLOAT           reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    (               reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    }               reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    VOID_TYPE       reduce using rule 97 (printf_expr -> error ( digit ) ; .)
    $end            reduce using rule 97 (printf_expr -> error ( digit ) ; .)


state 234

    (98) printf_expr -> error ( float ) ; .

    error           reduce using rule 98 (printf_expr -> error ( float ) ; .)
    IF              reduce using rule 98 (printf_expr -> error ( float ) ; .)
    FOR             reduce using rule 98 (printf_expr -> error ( float ) ; .)
    RETURN          reduce using rule 98 (printf_expr -> error ( float ) ; .)
    PRINTF          reduce using rule 98 (printf_expr -> error ( float ) ; .)
    INT_TYPE        reduce using rule 98 (printf_expr -> error ( float ) ; .)
    FLOAT_TYPE      reduce using rule 98 (printf_expr -> error ( float ) ; .)
    *               reduce using rule 98 (printf_expr -> error ( float ) ; .)
    VARIABLE        reduce using rule 98 (printf_expr -> error ( float ) ; .)
    -               reduce using rule 98 (printf_expr -> error ( float ) ; .)
    INTEGER         reduce using rule 98 (printf_expr -> error ( float ) ; .)
    FLOAT           reduce using rule 98 (printf_expr -> error ( float ) ; .)
    (               reduce using rule 98 (printf_expr -> error ( float ) ; .)
    }               reduce using rule 98 (printf_expr -> error ( float ) ; .)
    VOID_TYPE       reduce using rule 98 (printf_expr -> error ( float ) ; .)
    $end            reduce using rule 98 (printf_expr -> error ( float ) ; .)


state 235

    (25) assignment -> variable_or_pointer = & VARIABLE ; .

    error           reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    IF              reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    FOR             reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    RETURN          reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    PRINTF          reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    INT_TYPE        reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    FLOAT_TYPE      reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    *               reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    VARIABLE        reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    -               reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    INTEGER         reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    FLOAT           reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    (               reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    }               reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    VOID_TYPE       reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)
    $end            reduce using rule 25 (assignment -> variable_or_pointer = & VARIABLE ; .)


state 236

    (87) assignment -> variable_or_pointer = & error ; .

    error           reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    IF              reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    FOR             reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    RETURN          reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    PRINTF          reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    INT_TYPE        reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    FLOAT_TYPE      reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    *               reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    VARIABLE        reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    -               reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    INTEGER         reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    FLOAT           reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    (               reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    }               reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    VOID_TYPE       reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)
    $end            reduce using rule 87 (assignment -> variable_or_pointer = & error ; .)


state 237

    (26) assignment -> array = & VARIABLE ; .

    error           reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    IF              reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    FOR             reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    RETURN          reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    PRINTF          reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    INT_TYPE        reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    FLOAT_TYPE      reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    *               reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    VARIABLE        reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    -               reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    INTEGER         reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    FLOAT           reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    (               reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    }               reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    VOID_TYPE       reduce using rule 26 (assignment -> array = & VARIABLE ; .)
    $end            reduce using rule 26 (assignment -> array = & VARIABLE ; .)


state 238

    (88) assignment -> array = & error ; .

    error           reduce using rule 88 (assignment -> array = & error ; .)
    IF              reduce using rule 88 (assignment -> array = & error ; .)
    FOR             reduce using rule 88 (assignment -> array = & error ; .)
    RETURN          reduce using rule 88 (assignment -> array = & error ; .)
    PRINTF          reduce using rule 88 (assignment -> array = & error ; .)
    INT_TYPE        reduce using rule 88 (assignment -> array = & error ; .)
    FLOAT_TYPE      reduce using rule 88 (assignment -> array = & error ; .)
    *               reduce using rule 88 (assignment -> array = & error ; .)
    VARIABLE        reduce using rule 88 (assignment -> array = & error ; .)
    -               reduce using rule 88 (assignment -> array = & error ; .)
    INTEGER         reduce using rule 88 (assignment -> array = & error ; .)
    FLOAT           reduce using rule 88 (assignment -> array = & error ; .)
    (               reduce using rule 88 (assignment -> array = & error ; .)
    }               reduce using rule 88 (assignment -> array = & error ; .)
    VOID_TYPE       reduce using rule 88 (assignment -> array = & error ; .)
    $end            reduce using rule 88 (assignment -> array = & error ; .)


state 239

    (56) if_clause -> IF ( expr_1 ) { . body }
    (114) if_clause -> IF ( expr_1 ) { . error }
    (115) if_clause -> IF ( expr_1 ) { . body
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    error           shift and go to state 256
    }               reduce using rule 129 (empty -> .)
    VOID_TYPE       reduce using rule 129 (empty -> .)
    $end            reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

  ! error           [ reduce using rule 129 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 129 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 129 (empty -> .) ]
  ! IF              [ reduce using rule 129 (empty -> .) ]
  ! FOR             [ reduce using rule 129 (empty -> .) ]
  ! RETURN          [ reduce using rule 129 (empty -> .) ]
  ! PRINTF          [ reduce using rule 129 (empty -> .) ]
  ! *               [ reduce using rule 129 (empty -> .) ]
  ! VARIABLE        [ reduce using rule 129 (empty -> .) ]
  ! -               [ reduce using rule 129 (empty -> .) ]
  ! INTEGER         [ reduce using rule 129 (empty -> .) ]
  ! FLOAT           [ reduce using rule 129 (empty -> .) ]
  ! (               [ reduce using rule 129 (empty -> .) ]

    expr_1                         shift and go to state 55
    body                           shift and go to state 255
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 240

    (113) if_clause -> IF ( expr_1 ) body . }

    }               shift and go to state 257


state 241

    (112) if_clause -> IF ( expr_1 { body . }

    }               shift and go to state 258


state 242

    (111) if_clause -> IF ( error ) { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    body                           shift and go to state 259
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    expr_1                         shift and go to state 55
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 243

    (110) if_clause -> IF expr_1 ) { body . }

    }               shift and go to state 260


state 244

    (120) for_loop -> FOR ( assignment expr_1 expr_1 . ) { body }

    )               shift and go to state 261


state 245

    (57) for_loop -> FOR ( assignment expr_1 ; . expr_1 ) { body }
    (121) for_loop -> FOR ( assignment expr_1 ; . error ) { body }
    (122) for_loop -> FOR ( assignment expr_1 ; . expr_1 { body }
    (123) for_loop -> FOR ( assignment expr_1 ; . expr_1 ) body }
    (124) for_loop -> FOR ( assignment expr_1 ; . expr_1 ) { error }
    (125) for_loop -> FOR ( assignment expr_1 ; . expr_1 ) { body
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    error           shift and go to state 263
    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 262
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 246

    (119) for_loop -> FOR ( assignment error ; . expr_1 ) { body }
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 264
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 247

    (118) for_loop -> FOR ( error expr_1 ; . expr_1 ) { body }
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )
    (62) array -> . VARIABLE [ expr_1 ]

    -               shift and go to state 63
    *               shift and go to state 27
    VARIABLE        shift and go to state 80
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 265
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    variable_or_pointer            shift and go to state 79
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69
    array                          shift and go to state 81

state 248

    (117) for_loop -> FOR assignment expr_1 ; expr_1 . ) { body }

    )               shift and go to state 266


state 249

    (30) printf_expr -> PRINTF ( STRING ) ; .

    error           reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    IF              reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    FOR             reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    RETURN          reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    PRINTF          reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    INT_TYPE        reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    FLOAT_TYPE      reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    *               reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    VARIABLE        reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    -               reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    INTEGER         reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    FLOAT           reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    (               reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    }               reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    VOID_TYPE       reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)
    $end            reduce using rule 30 (printf_expr -> PRINTF ( STRING ) ; .)


state 250

    (31) printf_expr -> PRINTF ( digit ) ; .

    error           reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    IF              reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    FOR             reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    RETURN          reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    PRINTF          reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    INT_TYPE        reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    FLOAT_TYPE      reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    *               reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    VARIABLE        reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    -               reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    INTEGER         reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    FLOAT           reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    (               reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    }               reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    VOID_TYPE       reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)
    $end            reduce using rule 31 (printf_expr -> PRINTF ( digit ) ; .)


state 251

    (32) printf_expr -> PRINTF ( float ) ; .

    error           reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    IF              reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    FOR             reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    RETURN          reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    PRINTF          reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    INT_TYPE        reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    FLOAT_TYPE      reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    *               reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    VARIABLE        reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    -               reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    INTEGER         reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    FLOAT           reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    (               reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    }               reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    VOID_TYPE       reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)
    $end            reduce using rule 32 (printf_expr -> PRINTF ( float ) ; .)


state 252

    (102) printf_expr -> PRINTF ( error ) ; .

    error           reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    IF              reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    FOR             reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    RETURN          reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    PRINTF          reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    INT_TYPE        reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    FLOAT_TYPE      reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    *               reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    VARIABLE        reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    -               reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    INTEGER         reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    FLOAT           reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    (               reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    }               reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    VOID_TYPE       reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)
    $end            reduce using rule 102 (printf_expr -> PRINTF ( error ) ; .)


state 253

    (109) if_clause -> error ( expr_1 ) { body . }

    }               shift and go to state 267


state 254

    (116) for_loop -> error ( assignment expr_1 ; expr_1 . ) { body }

    )               shift and go to state 268


state 255

    (56) if_clause -> IF ( expr_1 ) { body . }
    (115) if_clause -> IF ( expr_1 ) { body .

  ! shift/reduce conflict for } resolved as shift
    }               shift and go to state 269
    error           reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)
    IF              reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)
    FOR             reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)
    RETURN          reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)
    PRINTF          reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)
    INT_TYPE        reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)
    FLOAT_TYPE      reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)
    *               reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)
    VARIABLE        reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)
    -               reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)
    INTEGER         reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)
    FLOAT           reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)
    (               reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)
    VOID_TYPE       reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)
    $end            reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .)

  ! }               [ reduce using rule 115 (if_clause -> IF ( expr_1 ) { body .) ]


state 256

    (114) if_clause -> IF ( expr_1 ) { error . }
    (68) line -> error . ;
    (126) declaration -> error . variable_list ;
    (77) assignment -> error . = expr_1 ;
    (84) assignment -> error . = & VARIABLE ;
    (109) if_clause -> error . ( expr_1 ) { body }
    (116) for_loop -> error . ( assignment expr_1 ; expr_1 ) { body }
    (95) expr_line -> error . ;
    (96) printf_expr -> error . ( STRING ) ;
    (97) printf_expr -> error . ( digit ) ;
    (98) printf_expr -> error . ( float ) ;
    (19) variable_list -> . variable_or_pointer
    (20) variable_list -> . array
    (21) variable_list -> . variable_or_pointer , variable_list
    (22) variable_list -> . array , variable_list
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]

    }               shift and go to state 270
    ;               shift and go to state 85
    =               shift and go to state 87
    (               shift and go to state 89
    *               shift and go to state 27
    VARIABLE        shift and go to state 88

    variable_list                  shift and go to state 86
    variable_or_pointer            shift and go to state 90
    array                          shift and go to state 91

state 257

    (113) if_clause -> IF ( expr_1 ) body } .

    error           reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    IF              reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    FOR             reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    RETURN          reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    PRINTF          reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    INT_TYPE        reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    FLOAT_TYPE      reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    *               reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    VARIABLE        reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    -               reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    INTEGER         reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    FLOAT           reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    (               reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    }               reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    VOID_TYPE       reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)
    $end            reduce using rule 113 (if_clause -> IF ( expr_1 ) body } .)


state 258

    (112) if_clause -> IF ( expr_1 { body } .

    error           reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    IF              reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    FOR             reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    RETURN          reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    PRINTF          reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    INT_TYPE        reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    FLOAT_TYPE      reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    *               reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    VARIABLE        reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    -               reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    INTEGER         reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    FLOAT           reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    (               reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    }               reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    VOID_TYPE       reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)
    $end            reduce using rule 112 (if_clause -> IF ( expr_1 { body } .)


state 259

    (111) if_clause -> IF ( error ) { body . }

    }               shift and go to state 271


state 260

    (110) if_clause -> IF expr_1 ) { body } .

    error           reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    IF              reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    FOR             reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    RETURN          reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    PRINTF          reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    INT_TYPE        reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    FLOAT_TYPE      reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    *               reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    VARIABLE        reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    -               reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    INTEGER         reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    FLOAT           reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    (               reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    }               reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    VOID_TYPE       reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)
    $end            reduce using rule 110 (if_clause -> IF expr_1 ) { body } .)


state 261

    (120) for_loop -> FOR ( assignment expr_1 expr_1 ) . { body }

    {               shift and go to state 272


state 262

    (57) for_loop -> FOR ( assignment expr_1 ; expr_1 . ) { body }
    (122) for_loop -> FOR ( assignment expr_1 ; expr_1 . { body }
    (123) for_loop -> FOR ( assignment expr_1 ; expr_1 . ) body }
    (124) for_loop -> FOR ( assignment expr_1 ; expr_1 . ) { error }
    (125) for_loop -> FOR ( assignment expr_1 ; expr_1 . ) { body

    )               shift and go to state 273
    {               shift and go to state 274


state 263

    (121) for_loop -> FOR ( assignment expr_1 ; error . ) { body }

    )               shift and go to state 275


state 264

    (119) for_loop -> FOR ( assignment error ; expr_1 . ) { body }

    )               shift and go to state 276


state 265

    (118) for_loop -> FOR ( error expr_1 ; expr_1 . ) { body }

    )               shift and go to state 277


state 266

    (117) for_loop -> FOR assignment expr_1 ; expr_1 ) . { body }

    {               shift and go to state 278


state 267

    (109) if_clause -> error ( expr_1 ) { body } .

    error           reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    IF              reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    FOR             reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    RETURN          reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    PRINTF          reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    INT_TYPE        reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    FLOAT_TYPE      reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    *               reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    VARIABLE        reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    -               reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    INTEGER         reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    FLOAT           reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    (               reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    }               reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    VOID_TYPE       reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)
    $end            reduce using rule 109 (if_clause -> error ( expr_1 ) { body } .)


state 268

    (116) for_loop -> error ( assignment expr_1 ; expr_1 ) . { body }

    {               shift and go to state 279


state 269

    (56) if_clause -> IF ( expr_1 ) { body } .

    error           reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    IF              reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    FOR             reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    RETURN          reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    PRINTF          reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    INT_TYPE        reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    FLOAT_TYPE      reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    *               reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    VARIABLE        reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    -               reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    INTEGER         reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    FLOAT           reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    (               reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    }               reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    VOID_TYPE       reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)
    $end            reduce using rule 56 (if_clause -> IF ( expr_1 ) { body } .)


state 270

    (114) if_clause -> IF ( expr_1 ) { error } .

    error           reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    IF              reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    FOR             reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    RETURN          reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    PRINTF          reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    INT_TYPE        reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    FLOAT_TYPE      reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    *               reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    VARIABLE        reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    -               reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    INTEGER         reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    FLOAT           reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    (               reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    }               reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    VOID_TYPE       reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)
    $end            reduce using rule 114 (if_clause -> IF ( expr_1 ) { error } .)


state 271

    (111) if_clause -> IF ( error ) { body } .

    error           reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    IF              reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    FOR             reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    RETURN          reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    PRINTF          reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    INT_TYPE        reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    FLOAT_TYPE      reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    *               reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    VARIABLE        reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    -               reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    INTEGER         reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    FLOAT           reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    (               reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    }               reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    VOID_TYPE       reduce using rule 111 (if_clause -> IF ( error ) { body } .)
    $end            reduce using rule 111 (if_clause -> IF ( error ) { body } .)


state 272

    (120) for_loop -> FOR ( assignment expr_1 expr_1 ) { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    assignment                     shift and go to state 47
    expr_1                         shift and go to state 55
    body                           shift and go to state 280
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 273

    (57) for_loop -> FOR ( assignment expr_1 ; expr_1 ) . { body }
    (123) for_loop -> FOR ( assignment expr_1 ; expr_1 ) . body }
    (124) for_loop -> FOR ( assignment expr_1 ; expr_1 ) . { error }
    (125) for_loop -> FOR ( assignment expr_1 ; expr_1 ) . { body
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    {               shift and go to state 281
    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    assignment                     shift and go to state 47
    expr_1                         shift and go to state 55
    body                           shift and go to state 282
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 274

    (122) for_loop -> FOR ( assignment expr_1 ; expr_1 { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    assignment                     shift and go to state 47
    expr_1                         shift and go to state 55
    body                           shift and go to state 283
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 275

    (121) for_loop -> FOR ( assignment expr_1 ; error ) . { body }

    {               shift and go to state 284


state 276

    (119) for_loop -> FOR ( assignment error ; expr_1 ) . { body }

    {               shift and go to state 285


state 277

    (118) for_loop -> FOR ( error expr_1 ; expr_1 ) . { body }

    {               shift and go to state 286


state 278

    (117) for_loop -> FOR assignment expr_1 ; expr_1 ) { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    assignment                     shift and go to state 47
    expr_1                         shift and go to state 55
    body                           shift and go to state 287
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 279

    (116) for_loop -> error ( assignment expr_1 ; expr_1 ) { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    assignment                     shift and go to state 47
    expr_1                         shift and go to state 55
    body                           shift and go to state 288
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 280

    (120) for_loop -> FOR ( assignment expr_1 expr_1 ) { body . }

    }               shift and go to state 289


state 281

    (57) for_loop -> FOR ( assignment expr_1 ; expr_1 ) { . body }
    (124) for_loop -> FOR ( assignment expr_1 ; expr_1 ) { . error }
    (125) for_loop -> FOR ( assignment expr_1 ; expr_1 ) { . body
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    error           shift and go to state 291
    }               reduce using rule 129 (empty -> .)
    VOID_TYPE       reduce using rule 129 (empty -> .)
    $end            reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

  ! error           [ reduce using rule 129 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 129 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 129 (empty -> .) ]
  ! IF              [ reduce using rule 129 (empty -> .) ]
  ! FOR             [ reduce using rule 129 (empty -> .) ]
  ! RETURN          [ reduce using rule 129 (empty -> .) ]
  ! PRINTF          [ reduce using rule 129 (empty -> .) ]
  ! *               [ reduce using rule 129 (empty -> .) ]
  ! VARIABLE        [ reduce using rule 129 (empty -> .) ]
  ! -               [ reduce using rule 129 (empty -> .) ]
  ! INTEGER         [ reduce using rule 129 (empty -> .) ]
  ! FLOAT           [ reduce using rule 129 (empty -> .) ]
  ! (               [ reduce using rule 129 (empty -> .) ]

    assignment                     shift and go to state 47
    expr_1                         shift and go to state 55
    body                           shift and go to state 290
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 282

    (123) for_loop -> FOR ( assignment expr_1 ; expr_1 ) body . }

    }               shift and go to state 292


state 283

    (122) for_loop -> FOR ( assignment expr_1 ; expr_1 { body . }

    }               shift and go to state 293


state 284

    (121) for_loop -> FOR ( assignment expr_1 ; error ) { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    assignment                     shift and go to state 47
    expr_1                         shift and go to state 55
    body                           shift and go to state 294
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 285

    (119) for_loop -> FOR ( assignment error ; expr_1 ) { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    assignment                     shift and go to state 47
    expr_1                         shift and go to state 55
    body                           shift and go to state 295
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 286

    (118) for_loop -> FOR ( error expr_1 ; expr_1 ) { . body }
    (9) body -> . line body
    (10) body -> . empty
    (11) line -> . declaration
    (12) line -> . assignment
    (13) line -> . if_clause
    (14) line -> . for_loop
    (15) line -> . expr_line
    (16) line -> . return_expr
    (17) line -> . printf_expr
    (68) line -> . error ;
    (129) empty -> .
    (18) declaration -> . type_var variable_list ;
    (126) declaration -> . error variable_list ;
    (127) declaration -> . type_var error ;
    (128) declaration -> . type_var variable_list
    (23) assignment -> . variable_or_pointer = expr_1 ;
    (24) assignment -> . array = expr_1 ;
    (25) assignment -> . variable_or_pointer = & VARIABLE ;
    (26) assignment -> . array = & VARIABLE ;
    (77) assignment -> . error = expr_1 ;
    (78) assignment -> . variable_or_pointer expr_1 ;
    (79) assignment -> . array expr_1 ;
    (80) assignment -> . variable_or_pointer = error ;
    (81) assignment -> . array = error ;
    (82) assignment -> . variable_or_pointer = expr_1
    (83) assignment -> . array = expr_1
    (84) assignment -> . error = & VARIABLE ;
    (85) assignment -> . variable_or_pointer & VARIABLE ;
    (86) assignment -> . array & VARIABLE ;
    (87) assignment -> . variable_or_pointer = & error ;
    (88) assignment -> . array = & error ;
    (89) assignment -> . variable_or_pointer = & VARIABLE
    (90) assignment -> . array = & VARIABLE
    (56) if_clause -> . IF ( expr_1 ) { body }
    (109) if_clause -> . error ( expr_1 ) { body }
    (110) if_clause -> . IF expr_1 ) { body }
    (111) if_clause -> . IF ( error ) { body }
    (112) if_clause -> . IF ( expr_1 { body }
    (113) if_clause -> . IF ( expr_1 ) body }
    (114) if_clause -> . IF ( expr_1 ) { error }
    (115) if_clause -> . IF ( expr_1 ) { body
    (57) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body }
    (116) for_loop -> . error ( assignment expr_1 ; expr_1 ) { body }
    (117) for_loop -> . FOR assignment expr_1 ; expr_1 ) { body }
    (118) for_loop -> . FOR ( error expr_1 ; expr_1 ) { body }
    (119) for_loop -> . FOR ( assignment error ; expr_1 ) { body }
    (120) for_loop -> . FOR ( assignment expr_1 expr_1 ) { body }
    (121) for_loop -> . FOR ( assignment expr_1 ; error ) { body }
    (122) for_loop -> . FOR ( assignment expr_1 ; expr_1 { body }
    (123) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) body }
    (124) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { error }
    (125) for_loop -> . FOR ( assignment expr_1 ; expr_1 ) { body
    (29) expr_line -> . expr_1 ;
    (94) expr_line -> . expr_1
    (95) expr_line -> . error ;
    (27) return_expr -> . RETURN expr_1 ;
    (28) return_expr -> . RETURN ;
    (91) return_expr -> . RETURN error ;
    (92) return_expr -> . RETURN expr_1
    (93) return_expr -> . RETURN
    (30) printf_expr -> . PRINTF ( STRING ) ;
    (31) printf_expr -> . PRINTF ( digit ) ;
    (32) printf_expr -> . PRINTF ( float ) ;
    (96) printf_expr -> . error ( STRING ) ;
    (97) printf_expr -> . error ( digit ) ;
    (98) printf_expr -> . error ( float ) ;
    (99) printf_expr -> . PRINTF STRING ) ;
    (100) printf_expr -> . PRINTF digit ) ;
    (101) printf_expr -> . PRINTF float ) ;
    (102) printf_expr -> . PRINTF ( error ) ;
    (103) printf_expr -> . PRINTF ( STRING ;
    (104) printf_expr -> . PRINTF ( digit ;
    (105) printf_expr -> . PRINTF ( float ;
    (106) printf_expr -> . PRINTF ( STRING )
    (107) printf_expr -> . PRINTF ( digit )
    (108) printf_expr -> . PRINTF ( float )
    (66) type_var -> . INT_TYPE
    (67) type_var -> . FLOAT_TYPE
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]
    (37) expr_1 -> . expr_2 > expr_1
    (38) expr_1 -> . expr_2 < expr_1
    (39) expr_1 -> . expr_2
    (40) expr_2 -> . expr_3 PLUS expr_2
    (41) expr_2 -> . expr_3 - expr_2
    (42) expr_2 -> . expr_3
    (43) expr_3 -> . expr_4 * expr_3
    (44) expr_3 -> . expr_4 / expr_3
    (45) expr_3 -> . expr_4
    (46) expr_4 -> . - expr_5
    (47) expr_4 -> . expr_5
    (48) expr_5 -> . variable_or_pointer INCR
    (49) expr_5 -> . expr_6
    (50) expr_6 -> . INTEGER
    (51) expr_6 -> . FLOAT
    (52) expr_6 -> . variable_or_pointer
    (53) expr_6 -> . function_call
    (54) expr_6 -> . array
    (55) expr_6 -> . ( expr_1 )
    (58) function_call -> . VARIABLE ( arguments_call )
    (59) function_call -> . VARIABLE ( )

    error           shift and go to state 43
    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 57
    FOR             shift and go to state 58
    RETURN          shift and go to state 59
    PRINTF          shift and go to state 60
    INT_TYPE        shift and go to state 19
    FLOAT_TYPE      shift and go to state 20
    *               shift and go to state 27
    VARIABLE        shift and go to state 39
    -               shift and go to state 63
    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    (               shift and go to state 40

    expr_1                         shift and go to state 55
    body                           shift and go to state 296
    line                           shift and go to state 44
    empty                          shift and go to state 45
    declaration                    shift and go to state 46
    assignment                     shift and go to state 47
    if_clause                      shift and go to state 48
    for_loop                       shift and go to state 49
    expr_line                      shift and go to state 50
    return_expr                    shift and go to state 51
    printf_expr                    shift and go to state 52
    type_var                       shift and go to state 53
    variable_or_pointer            shift and go to state 54
    array                          shift and go to state 56
    expr_2                         shift and go to state 61
    expr_3                         shift and go to state 62
    expr_4                         shift and go to state 64
    expr_5                         shift and go to state 65
    expr_6                         shift and go to state 66
    function_call                  shift and go to state 69

state 287

    (117) for_loop -> FOR assignment expr_1 ; expr_1 ) { body . }

    }               shift and go to state 297


state 288

    (116) for_loop -> error ( assignment expr_1 ; expr_1 ) { body . }

    }               shift and go to state 298


state 289

    (120) for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .

    error           reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    IF              reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    FOR             reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    RETURN          reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    PRINTF          reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    INT_TYPE        reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    FLOAT_TYPE      reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    *               reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    VARIABLE        reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    -               reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    INTEGER         reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    FLOAT           reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    (               reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    }               reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    VOID_TYPE       reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)
    $end            reduce using rule 120 (for_loop -> FOR ( assignment expr_1 expr_1 ) { body } .)


state 290

    (57) for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body . }
    (125) for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .

  ! shift/reduce conflict for } resolved as shift
    }               shift and go to state 299
    error           reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    IF              reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    FOR             reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    RETURN          reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    PRINTF          reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    INT_TYPE        reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    FLOAT_TYPE      reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    *               reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    VARIABLE        reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    -               reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    INTEGER         reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    FLOAT           reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    (               reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    VOID_TYPE       reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)
    $end            reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .)

  ! }               [ reduce using rule 125 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body .) ]


state 291

    (124) for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error . }
    (68) line -> error . ;
    (126) declaration -> error . variable_list ;
    (77) assignment -> error . = expr_1 ;
    (84) assignment -> error . = & VARIABLE ;
    (109) if_clause -> error . ( expr_1 ) { body }
    (116) for_loop -> error . ( assignment expr_1 ; expr_1 ) { body }
    (95) expr_line -> error . ;
    (96) printf_expr -> error . ( STRING ) ;
    (97) printf_expr -> error . ( digit ) ;
    (98) printf_expr -> error . ( float ) ;
    (19) variable_list -> . variable_or_pointer
    (20) variable_list -> . array
    (21) variable_list -> . variable_or_pointer , variable_list
    (22) variable_list -> . array , variable_list
    (35) variable_or_pointer -> . * VARIABLE
    (36) variable_or_pointer -> . VARIABLE
    (62) array -> . VARIABLE [ expr_1 ]

    }               shift and go to state 300
    ;               shift and go to state 85
    =               shift and go to state 87
    (               shift and go to state 89
    *               shift and go to state 27
    VARIABLE        shift and go to state 88

    variable_list                  shift and go to state 86
    variable_or_pointer            shift and go to state 90
    array                          shift and go to state 91

state 292

    (123) for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .

    error           reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    IF              reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    FOR             reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    RETURN          reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    PRINTF          reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    INT_TYPE        reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    FLOAT_TYPE      reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    *               reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    VARIABLE        reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    -               reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    INTEGER         reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    FLOAT           reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    (               reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    }               reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    VOID_TYPE       reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)
    $end            reduce using rule 123 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) body } .)


state 293

    (122) for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .

    error           reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    IF              reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    FOR             reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    RETURN          reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    PRINTF          reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    INT_TYPE        reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    FLOAT_TYPE      reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    *               reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    VARIABLE        reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    -               reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    INTEGER         reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    FLOAT           reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    (               reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    }               reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    VOID_TYPE       reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)
    $end            reduce using rule 122 (for_loop -> FOR ( assignment expr_1 ; expr_1 { body } .)


state 294

    (121) for_loop -> FOR ( assignment expr_1 ; error ) { body . }

    }               shift and go to state 301


state 295

    (119) for_loop -> FOR ( assignment error ; expr_1 ) { body . }

    }               shift and go to state 302


state 296

    (118) for_loop -> FOR ( error expr_1 ; expr_1 ) { body . }

    }               shift and go to state 303


state 297

    (117) for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .

    error           reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    IF              reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    FOR             reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    RETURN          reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    PRINTF          reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    INT_TYPE        reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    FLOAT_TYPE      reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    *               reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    VARIABLE        reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    -               reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    INTEGER         reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    FLOAT           reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    (               reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    }               reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    VOID_TYPE       reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)
    $end            reduce using rule 117 (for_loop -> FOR assignment expr_1 ; expr_1 ) { body } .)


state 298

    (116) for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .

    error           reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    IF              reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    FOR             reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    RETURN          reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    PRINTF          reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    INT_TYPE        reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    FLOAT_TYPE      reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    *               reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    VARIABLE        reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    -               reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    INTEGER         reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    FLOAT           reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    (               reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    }               reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    VOID_TYPE       reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)
    $end            reduce using rule 116 (for_loop -> error ( assignment expr_1 ; expr_1 ) { body } .)


state 299

    (57) for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .

    error           reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    IF              reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    FOR             reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    RETURN          reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    PRINTF          reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    INT_TYPE        reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    FLOAT_TYPE      reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    *               reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    VARIABLE        reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    -               reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    INTEGER         reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    FLOAT           reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    (               reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    }               reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    VOID_TYPE       reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)
    $end            reduce using rule 57 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { body } .)


state 300

    (124) for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .

    error           reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    IF              reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    FOR             reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    RETURN          reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    PRINTF          reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    INT_TYPE        reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    FLOAT_TYPE      reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    *               reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    VARIABLE        reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    -               reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    INTEGER         reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    FLOAT           reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    (               reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    }               reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    VOID_TYPE       reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)
    $end            reduce using rule 124 (for_loop -> FOR ( assignment expr_1 ; expr_1 ) { error } .)


state 301

    (121) for_loop -> FOR ( assignment expr_1 ; error ) { body } .

    error           reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    IF              reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    FOR             reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    RETURN          reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    PRINTF          reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    INT_TYPE        reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    FLOAT_TYPE      reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    *               reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    VARIABLE        reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    -               reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    INTEGER         reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    FLOAT           reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    (               reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    }               reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    VOID_TYPE       reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)
    $end            reduce using rule 121 (for_loop -> FOR ( assignment expr_1 ; error ) { body } .)


state 302

    (119) for_loop -> FOR ( assignment error ; expr_1 ) { body } .

    error           reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    IF              reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    FOR             reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    RETURN          reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    PRINTF          reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    INT_TYPE        reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    FLOAT_TYPE      reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    *               reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    VARIABLE        reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    -               reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    INTEGER         reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    FLOAT           reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    (               reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    }               reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    VOID_TYPE       reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)
    $end            reduce using rule 119 (for_loop -> FOR ( assignment error ; expr_1 ) { body } .)


state 303

    (118) for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .

    error           reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    IF              reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    FOR             reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    RETURN          reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    PRINTF          reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    INT_TYPE        reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    FLOAT_TYPE      reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    *               reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    VARIABLE        reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    -               reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    INTEGER         reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    FLOAT           reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    (               reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    }               reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    VOID_TYPE       reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)
    $end            reduce using rule 118 (for_loop -> FOR ( error expr_1 ; expr_1 ) { body } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ( in state 39 resolved as shift
WARNING: shift/reduce conflict for error in state 41 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 41 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 41 resolved as shift
WARNING: shift/reduce conflict for error in state 44 resolved as shift
WARNING: shift/reduce conflict for IF in state 44 resolved as shift
WARNING: shift/reduce conflict for FOR in state 44 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 44 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 44 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 44 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 44 resolved as shift
WARNING: shift/reduce conflict for * in state 44 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 44 resolved as shift
WARNING: shift/reduce conflict for - in state 44 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 44 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 44 resolved as shift
WARNING: shift/reduce conflict for ( in state 44 resolved as shift
WARNING: shift/reduce conflict for - in state 54 resolved as shift
WARNING: shift/reduce conflict for * in state 54 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 54 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 54 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 54 resolved as shift
WARNING: shift/reduce conflict for ( in state 54 resolved as shift
WARNING: shift/reduce conflict for - in state 56 resolved as shift
WARNING: shift/reduce conflict for * in state 56 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 56 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 56 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 56 resolved as shift
WARNING: shift/reduce conflict for ( in state 56 resolved as shift
WARNING: shift/reduce conflict for error in state 59 resolved as shift
WARNING: shift/reduce conflict for - in state 59 resolved as shift
WARNING: shift/reduce conflict for * in state 59 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 59 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 59 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 59 resolved as shift
WARNING: shift/reduce conflict for ( in state 59 resolved as shift
WARNING: shift/reduce conflict for - in state 62 resolved as shift
WARNING: shift/reduce conflict for * in state 64 resolved as shift
WARNING: shift/reduce conflict for ( in state 80 resolved as shift
WARNING: shift/reduce conflict for * in state 208 resolved as shift
WARNING: shift/reduce conflict for - in state 208 resolved as shift
WARNING: shift/reduce conflict for error in state 239 resolved as shift
WARNING: shift/reduce conflict for IF in state 239 resolved as shift
WARNING: shift/reduce conflict for FOR in state 239 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 239 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 239 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 239 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 239 resolved as shift
WARNING: shift/reduce conflict for * in state 239 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 239 resolved as shift
WARNING: shift/reduce conflict for - in state 239 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 239 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 239 resolved as shift
WARNING: shift/reduce conflict for ( in state 239 resolved as shift
WARNING: shift/reduce conflict for } in state 255 resolved as shift
WARNING: shift/reduce conflict for error in state 281 resolved as shift
WARNING: shift/reduce conflict for IF in state 281 resolved as shift
WARNING: shift/reduce conflict for FOR in state 281 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 281 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 281 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 281 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 281 resolved as shift
WARNING: shift/reduce conflict for * in state 281 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 281 resolved as shift
WARNING: shift/reduce conflict for - in state 281 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 281 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 281 resolved as shift
WARNING: shift/reduce conflict for ( in state 281 resolved as shift
WARNING: shift/reduce conflict for } in state 290 resolved as shift
WARNING: reduce/reduce conflict in state 85 resolved using rule (line -> error ;)
WARNING: rejected rule (expr_line -> error ;) in state 85
WARNING: Rule (expr_line -> error ;) is never reduced
